C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE CPU
OBJECT MODULE PLACED IN .\Output\CPU.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE source36\CPU.c LARGE OMF2 ROM(D512K) OPTIMIZE(9,SPEED) REGFILE(.\Output\
                    -TW8836B_EVB11.ORC) BROWSE INCDIR(SiI-SW;SiI-SW\HAL;SiI-SW\DEBUG;SiI-SW\CEC;.\Source36\LIB) DEFINE(EVB_11,nullFn=//) DEBU
                    -G CODE PRINT(.\List\CPU.lst) TABS(2) OBJECT(.\Output\CPU.obj)

line level    source

   1          /**
   2           * @file
   3           * CPU.c 
   4           * @author Harry Han
   5           * @author YoungHwan Bae
   6           * @author Brian Kang
   7           * @version 1.0
   8           * @section LICENSE
   9           *  Copyright (C) 2011~2014 Intersil Corporation
  10           * @section DESCRIPTION
  11           *  8051 MCU file
  12           *
  13          */
  14          /*
  15          Disclaimer: THIS INFORMATION IS PROVIDED 'AS-IS' FOR EVALUATION PURPOSES ONLY.  
  16          INTERSIL CORPORATION AND ITS SUBSIDIARIES ('INTERSIL') DISCLAIM ALL WARRANTIES, 
  17          INCLUDING WITHOUT LIMITATION FITNESS FOR A PARTICULAR PURPOSE AND MERCHANTABILITY.  
  18          Intersil provides evaluation platforms to help our customers to develop products. 
  19          However, factors beyond Intersil's control could significantly affect Intersil 
  20          product performance. 
  21          It remains the customers' responsibility to verify the actual system performance.
  22          */
  23          /*
  24          Instruction
  25              http://www.keil.com/dd/docs/datashts/dcd/dp80390_instr.pdf
  26          Register Bank
  27              http://www.keil.com/support/man/docs/c51/c51_le_regbankaccess.htm
  28              By default, all non-interrupt functions use register bank 0.  
  29          */
  30          #include "config.h"
  31          #include "reg.h"
  32          #include "typedefs.h"
  33          #include "TW8836.h"
  34          
  35          #include "Global.h"
  36          #include "printf.h"
  37          #include "I2C.h"
  38          #include "CPU.h"
  39          #include "Remo.h"
  40          #include "TouchKey.h"
  41          
  42          /*
  43          TW8836 MCU --DP80390XP compatible--
  44          
  45          Cache 256 Bytes
  46          XDATA   2KByte
  47          
  48                                          CFFF+-----------+
  49                                              |  Chip     |
  50                                              |  Register |
  51              FF+---------------------+   0C00+-----------+
  52                | Internal |    SFR   |       |           |
  53                |   RAM    |          |       |  unused   |
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 2   

  54              7F+----------+----------+   0800+-----------+
  55                |     Internal        |       |  Data     |
  56                |       RAM           |       |  Memory   |
  57              00+---------------------+   0000+-----------+
  58                  IDATA        DATA
  59          
  60          
  61              00~07  Reg. Bank0
  62              08~0F  Reg. Bank1
  63              10~17  Reg. Bank2
  64              18~1F  Reg. Bank3
  65              20~27  Bit 00~3F
  66              28~2F  Bit 40~7F
  67              30~7F  General User RAM & Stack Space
  68          
  69          Register Bank
  70              By default, register bank0 us used.
  71              Interrupt use register bank1,2,3.
  72              Tip.If Interrupt does not use, code can use these as data memory.
  73          Bit memory
  74              Use SETB, CLR commands
  75          
  76          SFR memory
  77          
  78          TW8836B SFR  MAP------------
  79             -0-   -1-   -2-   -3-   -4-   -5-   -6-   -7-   
  80          80:P0    SP    DPL0  DPH0  DPL1  DPH1  DPS   PCON  
  81          88:TCON  TMOD  TL0   TL1   TH0   TH1   CKCON ..... 
  82          90:P1    EXIF  _WTST _DPX0 ..... _DPX1 ..... ..... 
  83          98:SCON0 SBUF0 BANK  ..... CACHE ACON  FIFO0 FIFO1 
  84          A0:P2    ..... ..... ..... ..... ..... ..... ..... 
  85          A8:IE    ..... ..... ..... ..... ..... ..... ..... 
  86          B0:P3    ..... ..... ..... ..... ..... ..... ..... 
  87          B8:IP    ..... ..... ..... ..... ..... ..... ..... 
  88          C0:SCON1 SBUF1 CCL1  CCH1  CCL2  CCH2  CCL3  CCH3  
  89          C8:T2CON T2IF  RLDL  RLDH  TL2   TH2   CCEN  ..... 
  90          D0:PSW   ..... ..... ..... ..... ..... ..... ..... 
  91          D8:WDCON ..... ..... ..... ..... ..... ..... ..... 
  92          E0:ACC   ..... CAMC  ..... ..... ..... ..... ..... 
  93          E8:EIE   STAT  _MXAX TA    ..... ..... ..... ..... 
  94          F0:B     ..... ..... ..... ..... ..... ..... ..... 
  95          F8:EIP   ..... E2IF  E2IE  E2IP  E2IM  E2IT  .....
  96          
  97          StackPointer:
  98              It starts from 07h in startup.
  99              On start up code, it use below.
 100                  IF PBPSTACK <> 0
 101                  EXTRN DATA (?C_PBP)
 102                          MOV     ?C_PBP,#LOW PBPSTACKTOP
 103                  ENDIF
 104                          MOV     SP,#?STACK-1
 105                          LJMP    ?C_START
 106              After reset, the stack pointer is initialized to 07h. The stack will 
 107              start growing up from address 8h.
 108              The Keil C compiler uses internal DATA memory for your variables and also 
 109              allows you to use register banks 1, 2, and 3. If the stack pointer were not 
 110              adjusted, calls to functions and interrupts would overwrite your variables.
 111              Therefore, the last thing the startup code does is to set the stack pointer 
 112              to the end of all your internal DATA variables.
 113          
 114          Interrupt
 115          # bank name  enable prio   flag    Port func    description
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 3   

 116          -- -  ----   ----   ----   ----    ---- -----   -----------
 117          0  1  EX0    IE.0   IP.0   IE0     P2.0 ext0_   chip interrupt. ->video ISR.
 118          1  1  ET0    IE.1   IP.1   TF0          timer0_ time tick
 119          2  1  EX1  IE.2   IP.2   IE1     P2.1 ext1_   DE(data enable) end.
 120          3  1  ET1  IE.3   IP.3   TF1          timer1_ ->touch.
 121          4  2  ES0    IE.4   IP.4   RI/TI        uart0_  uart0.
 122          5  1  ET2  IE.5   IP.5   T2IF         timer2_ ->remo sampling
 123          6  1  ES1    IE.6   IP.6   RI1/TI1      uart1_
 124          7  1  EINT2  EIE.0  EIP.0  EIF.0   P2.2 ext2_   DMA done.
 125          8  1  EINT3  EIE.1  EIP.1  EIF.1   P2.3 ext3_   Touch_Ready interrupt.
 126          9  1  EINT4  EIE.2  EIP.2  EIF.2        ext4_   xram 7FF access by I2C.
 127          10 1  EINT5  EIE.3  EIP.3  EIF.3        ext5_   
 128          11 1  EINT6  EIE.4  EIP.4  EIF.4   P2.4 ext6_   Touch_Pen interrupt.
 129          12 3  EWDI   EIE.5  EIP.5          WDIF watchdog_
 130          13 1  EINT7  E2IE.0 E2IP.0 E2IF.0  P1.0 ext7_   Programable. P1.0 Pin60
 131          14 1  EINT8  E2IE.1 E2IP.1 E2IF.1  P1.1 ext8_   Programable. P1.1 Pin61
 132          15 1  EINT9  E2IE.2 E2IP.2 E2IF.2  P1.2 ext9_   Programable. P1.2 Pin62
 133          16 1  EINT10 E2IE.3 E2IP.3 E2IF.3  P1.3 ext10_  Programable. P1.3 Pin63
 134          17 1  EINT11 E2IE.4 E2IP.4 E2IF.4  P1.4 ext11_  Programable. P1.4 Pin87  ->remo activate
 135          18 1  EINT12 E2IE.5 E2IP.5 E2IF.5  P1.5 ext12_  Programable. P1.5 Pin86
 136          19 1  EINT13 E2IE.6 E2IP.6 E2IF.6  P1.6 ext13_  Programable. P1.6 Pin114
 137          20 1  EINT14 E2IE.7 E2IP.7 E2IF.7  P1.7 ext14_  Programable. P1.7 Pin115
 138          
 139          Interrupt Polling Sequence
 140          EX0 ET0 EX1 ET1 ES ...
 141          The "using" function attribute is used to select a register bank 
 142          
 143          */
 144          
 145          //===== memory register ========
 146          volatile BYTE XDATA *DATA regTW88 = REG_START_ADDRESS;
 147          
 148          DWORD ExtIntCount = 0;
 149          
 150          //===== interrupt status ========
 151          DATA  WORD  MCU_INT_STATUS=0;
 152          DATA  BYTE  EXINT_STATUS = 0;
 153          
 154          #ifdef DEBUG_ISR
              XDATA WORD INTR_counter[21];
              #endif
 157          #ifdef DEBUG_UART
              XDATA BYTE UART0_OVERFLOW_counter;
              XDATA BYTE UART0_MAX_counter;
              #endif
 161          
 162          
 163          //==========================
 164          // PROTOTYPE for Internal 
 165          //==========================
 166          //===== Remo ========
 167          //TW8835 EVB uses P1_2(ext9_int), 
 168          //TW8836 EVB uses P1_4(ext11_int).
 169          void InitRemoTimer(void);
 170          
 171          
 172          
 173          
 174          //*****************************************************************************
 175          //*      Ext Int 0 Interrupt (Low / Falling)  (Internal)  : <<Chip Status>> P2.0
 176          //*****************************************************************************
 177          
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 4   

 178          //===== interrupt status ========
 179          DATA  BYTE  INT_STATUS=0;
 180          DATA  BYTE  INT_MASK=0;
 181          DATA  BYTE  INT_STATUS2=0;
 182          DATA  BYTE  INT_STATUS3=0;  //for debug ext4_intr
 183          DATA  BYTE  INT_STATUS_ACC=0;
 184          DATA  BYTE  INT_STATUS2_ACC=0;
 185          DATA  WORD  VH_Loss_Changed=0;
 186          
 187          /**
 188          * chip interrupt service routine.
 189          *
 190          * enable  SFR_EX0
 191          * port    P2.0
 192          *
 193          * Use ReadTW8A() and WriteTW8A().
 194          * If use ReadTW88() and WriteTW88(), compiler omit PUSH/POP PSW.
 195          */
 196          void ext0_int(void) interrupt 0 using 2
 197          {
 198   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0001;
                INTR_counter[0]++;
              #endif
 202   1          /* do not update if g_access was 0 */
 203   1        if(g_access==0)
 204   1          return;
 205   1      
 206   1          /* read register */
 207   1        INT_STATUS  = ReadTW8A(REG002) & 0xEF;
 208   1        INT_MASK    = ReadTW8A(REG003);
 209   1        INT_STATUS2 = ReadTW8A(REG004);
 210   1          /* clear */
 211   1        WriteTW8A(REG002, INT_STATUS );       //clear 
 212   1        WriteTW8A(REG004, INT_STATUS2 & 0x07);    //clear
 213   1      
 214   1        if(INT_STATUS & 0x02)           //keep 0x02.
 215   1          VH_Loss_Changed++;
 216   1      
 217   1          /* accumulate */
 218   1        INT_STATUS_ACC |= INT_STATUS;
 219   1        INT_STATUS2_ACC |= INT_STATUS2;
 220   1      }
 221          
 222          
 223          //*****************************************************************************
 224          //*      Timer 0 Interrupt                  : <<System Timer>>                                               
 225          //*****************************************************************************
 226          //===== Timer0 =======
 227          //NOTE: To read ISR related value that bigger than BYTE, use SFRB_ET0.
 228          DATA  BYTE    tic01=0;        //unit 1msec
 229          DATA  WORD    tic_pc=0;
 230          DATA  WORD    tic_task=0;
 231          DATA  BYTE  tic_timer=0;
 232          DATA  DWORD SystemClock=0L;     //unit 10msec
 233          DATA  DWORD OsdTimerClock=0L;
 234          
 235          /**
 236          * timer0 interrupt service routine
 237          *
 238          * 1 msec timer tic
 239          *  use 10us @27Mhz
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 5   

 240          *
 241          * enable: SFT_ET0
 242          * port:   NONE
 243          */
 244          void timer0_int(void) interrupt 1 using 1
 245          {
 246   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0002;
                INTR_counter[1]++;
              #endif
 250   1      
 251   1        tic01++;
 252   1        tic01 %= 10;    
 253   1        if ( tic01 == 0 ) {
 254   2          SystemClock++;
 255   2          if(OsdTimerClock)
 256   2            OsdTimerClock--;
 257   2        }
 258   1        tic_pc++;   //WORD size.
 259   1        tic_task++;   //WORD size.
 260   1        if(tic_timer)
 261   1          tic_timer--;
 262   1      }
 263          //*****************************************************************************
 264          //*      Ext Int 1 Interrupt  (Low / Falling)     : <<DE End>>  P2.1
 265          //*****************************************************************************
 266          /*
 267          * DE End interrupt service routine
 268          *
 269          * enable: SFR_EX1
 270          * port:   P2.1
 271          *
 272          * usage:
 273          * ext1_intr_flag =0;    //clear
 274          * SFRB_EX1 = 1;     //enable
 275          * while(!ext1_intr_flag); //wait
 276          *
 277          */
 278          BYTE ext1_intr_flag;
 279          
 280          void ext1_int(void) interrupt 2 using 1
 281          {
 282   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0004;
                INTR_counter[2]++;
              #endif
 286   1      
 287   1        ext1_intr_flag = 1;
 288   1        SFRB_EX1 = 0; /* disable EX1 */
 289   1      }
 290          
 291          //****************************************************************************
 292          //*      Timer 1 Interrupt : for Touch sensing & key sensing                                           
 293          //****************************************************************************
 294          WORD  CpuTouchX, CpuTouchY, CpuZ1, CpuZ2;
 295          BYTE /*bit*/    CpuTouchPressed=0;
 296          WORD  CpuAUX0 = 0;
 297          WORD  CpuAUX1 = 0;
 298          WORD  CpuAUX2 = 0;
 299          WORD  CpuAUX3 = 0;
 300          BYTE  CpuAUX0_Changed = 0;
 301          BYTE  CpuAUX1_Changed = 0;
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 6   

 302          BYTE  CpuAUX2_Changed = 0;
 303          BYTE  CpuAUX3_Changed = 0;
 304          BYTE  CpuTouchStep=0, CpuTouchChanged=0;
 305          WORD  CpuTouchSkipCount=0;
 306          
 307          #define ReadTscData(TscData)    \
 308              TscData = ReadTW8A(REG0B2); \
 309              TscData <<= 4;              \
 310              TscData += ReadTW8A(REG0B3) 
 311          //---------------------
 312          /**
 313          * timer1 interrupt service routine for Touch
 314          *
 315          * every 500usec. use 82uS @ 27MHz
 316          * @todo too big
 317          *
 318          * enable  SFR_ET1
 319          * port    NONE
 320          *
 321          */
 322          #if defined(SUPPORT_TOUCH)
 323          void timer1_int(void) interrupt 3 using 1
 324          {
 325   1        static WORD TX,TY;
 326   1        static WORD temp;
 327   1        WORD TscData;
 328   1        WORD diff;
 329   1      
 330   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0008;
                INTR_counter[3]++;
              #endif
 334   1      
 335   1        if(g_access==0)
 336   1          return;
 337   1      
 338   1        if(CpuTouchSkipCount) {
 339   2          CpuTouchSkipCount--;
 340   2          return;
 341   2        }
 342   1      
 343   1        if ( CpuTouchStep == 0 ) {        // start Measure Z2
 344   2          //TSC MODE : 2 : Z2 measure
 345   2          ReadTscData(TscData);
 346   2          if ( TscData > 0x800 ) {          
 347   3            WriteTW8A(REG0B0, 0x01 );   // adc  mode Z1
 348   3            CpuTouchStep++;         // 1
 349   3            temp = 0;           // clear
 350   3            CpuZ2 = TscData;              
 351   3          }
 352   2          else {
 353   3            CpuTouchStep = 5;
 354   3          }
 355   2        }
 356   1        else if ( CpuTouchStep == 1 ) {      // check Z1
 357   2          //TSC MODE : 1 : Z1 measure
 358   2          ReadTscData(TscData);
 359   2          if ( TscData > temp ) diff = TscData - temp;
 360   2          else          diff = temp - TscData;
 361   2      
 362   2          if ( diff < 10 ) {          // find stable value
 363   3            if ( TscData < 100 ) {      // no touch
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 7   

 364   4              CpuTouchPressed = 0;
 365   4              CpuTouchStep = 5;
 366   4              CpuTouchChanged++;
 367   4            }
 368   3            else {
 369   4              WriteTW8A(REG0B0, 0 );    // adc start with mode XPOS
 370   4              CpuTouchStep++;       // restart Touch measurement
 371   4              temp = 0;         // clear
 372   4            }
 373   3          }
 374   2          else {
 375   3            temp = TscData;         // redo measure
 376   3            //--WriteTW8A(REG0B0, 0x01 ); // adc  mode Z1
 377   3          }
 378   2        }
 379   1        else if ( CpuTouchStep == 2 ) {      // check XPOS
 380   2          //TSC MODE : 0 : X position measure
 381   2          ReadTscData(TscData);
 382   2      
 383   2          if ( TscData > temp ) diff = TscData - temp;
 384   2          else          diff = temp - TscData;
 385   2            
 386   2          if ( diff < 10 ) {          // find stable value
 387   3            WriteTW8A(REG0B0, 0x03 );   // adc start with mode YPOS
 388   3            CpuTouchStep++;
 389   3            temp = 0;           // clear
 390   3            TX = TscData;
 391   3          }
 392   2          else {
 393   3            temp = TscData;         // redo measure
 394   3            //--WriteTW8A(REG0B0, 0 );    // adc start with mode XPOS
 395   3          }
 396   2        }
 397   1        else if ( CpuTouchStep == 3 ) {     // check YPOS
 398   2          //TSC MODE : 3 : Y position measure
 399   2          ReadTscData(TscData);
 400   2      
 401   2          if ( TscData > temp ) diff = TscData - temp;
 402   2          else          diff = temp - TscData;
 403   2      
 404   2          if ( diff < 10 ) {          // find stable value
 405   3            WriteTW8A(REG0B0, 0x01 );   // adc start with mode Z1
 406   3            temp = 0;           // clear
 407   3            CpuTouchStep++;
 408   3            TY = TscData;
 409   3          }
 410   2          else {
 411   3            temp = TscData;         // redo measure
 412   3            //--WriteTW8A(REG0B0, 0x03 ); // adc start with mode YPOS
 413   3          }
 414   2        }
 415   1        else if ( CpuTouchStep == 4 ) {     // check z1
 416   2          //TSC MODE : 1 : Z1 measure
 417   2          ReadTscData(TscData);
 418   2      
 419   2          if ( TscData > temp ) diff = TscData - temp;
 420   2          else            diff = temp - TscData;
 421   2      
 422   2          if ( diff < 10 ) {          // find stable value
 423   3            if ( TscData < 100 ) {      // no touch, reset touch interrupt
 424   4              CpuTouchPressed = 0;
 425   4              CpuTouchChanged++;
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 8   

 426   4            }
 427   3            else {
 428   4              //===================
 429   4              //
 430   4              //===================
 431   4              CpuTouchX = TX;
 432   4              CpuTouchY = TY;
 433   4              CpuZ1 = TscData;
 434   4              CpuTouchChanged++;
 435   4              CpuTouchPressed = 1;
 436   4            }
 437   3            CpuTouchStep++;
 438   3          }
 439   2          else {
 440   3            temp = TscData;         // redo measure
 441   3            //--WriteTW8A(REG0B0, 0x01 ); // adc start with mode Z
 442   3          }
 443   2        }
 444   1        else if ( CpuTouchStep == 5 ) {     // Start AUX input check
 445   2          WriteTW8A(REG0B0, 0x07 );     // write Start, erase Ready, mode AUX3
 446   2          CpuTouchStep++;
 447   2          temp = 0;
 448   2        }
 449   1        else if ( CpuTouchStep == 6 ) { 
 450   2          //TSC MODE : 7 : AUX3 measure
 451   2          ReadTscData(TscData);
 452   2      
 453   2          if ( TscData > temp ) diff = TscData - temp;
 454   2          else          diff = temp - TscData;
 455   2            
 456   2          if ( diff < 10 ) {          // find stable value
 457   3            CpuAUX3 = TscData;
 458   3            CpuAUX3_Changed++;
 459   3            WriteTW8A(REG0B0, 2 );      // write Start, erase Ready, mode Z2
 460   3            temp = 0;
 461   3            CpuTouchStep = 0;             
 462   3          }
 463   2          else {
 464   3            temp = TscData;         // redo measure
 465   3            //--WriteTW8A(REG0B0, 7 );    // write Start, erase Ready, mode AUX[3]
 466   3          }
 467   2        }
 468   1      }
 469          #else
              /**
              * If select only SUPPORT_KEYPAD, FW will use a Polling, and will not use a interrupt.
              */
              void timer1_int(void) interrupt 3 using 1
              {
              #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0008;
                INTR_counter[3]++;
              #endif
              
                return;
              }
              #endif //..SUPPORT_TOUCH..SUPPORT_KEYPAD
 483          #undef ReadTscData
 484          
 485          
 486          //*****************************************************************************
 487          //      UART 0 Interrupt                                                   
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 9   

 488          //*****************************************************************************
 489          DATA  BYTE  RS_buf[RS_BUF_MAX];
 490          DATA  BYTE  RS_in=0;
 491          DATA  BYTE  RS_out=0;
 492              bit   RS_Xbusy=0;
 493          
 494          /**
 495          * UART0 interrupt service routine
 496          * 
 497          * enable SFR_ES0
 498          */
 499          void uart0_int(void) interrupt 4 using 2
 500          {
 501   1        BYTE  count;
 502   1      
 503   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0010;
                INTR_counter[4]++;
              #endif
 507   1      
 508   1        if( SFRB_RI ) {         //--- Receive interrupt ----
 509   2          SFRB_RI = 0;
 510   2          //if ( SFR_UART0FIFO & 0x80 ) {   // is it use fifo?
 511   2            count = SFR_UART0FIFO & 0x1F;
 512   2            if ( count & 0x10) {
 513   3              SFR_UART0FIFO = 0x90;   // overflowed, buffer clear
 514   3      #ifdef DEBUG_UART
                      UART0_OVERFLOW_counter++;
              #endif
 517   3            }
 518   2            else {
 519   3      #ifdef DEBUG_UART
                      if(UART0_MAX_counter < count)
                        UART0_MAX_counter = count;
              #endif
 523   3              while (count) {
 524   4                RS_buf[RS_in++] = SFR_SBUF;
 525   4                if( RS_in>=RS_BUF_MAX ) RS_in = 0;
 526   4                count--;
 527   4              };
 528   3            }
 529   2          //}
 530   2          //else {
 531   2          //  RS_buf[RS_in++] = SFR_SBUF;
 532   2          //  if( RS_in>=RS_BUF_MAX ) RS_in = 0;
 533   2          //}
 534   2        }
 535   1      
 536   1        if( SFRB_TI ) {         //--- Transmit interrupt ----
 537   2          SFRB_TI = 0;
 538   2          RS_Xbusy=0;
 539   2        }
 540   1      }
 541          
 542          //****************************************************************************
 543          //*      Timer 2 Interrupt                : <<Remo Timer>>
 544          //****************************************************************************
 545          #define REMO_IN   PORT_REMO
 546          
 547          #ifdef REMO_RC5
 548            bit         RemoPhase1, RemoPhase2;
 549            IDATA BYTE  RemoDataReady=0;
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 10  

 550            IDATA BYTE  RemoSystemCode, RemoDataCode;
 551            IDATA DWORD RemoReceivedTime;
 552              #ifdef DEBUG_REMO
                    IDATA BYTE  RemoSystemCode0, RemoDataCode0;
                    IDATA BYTE  RemoSystemCode1, RemoDataCode1;
                    IDATA BYTE  RemoSystemCode2, RemoDataCode2;
                    IDATA BYTE  RemoCaptureDisable=0;
                  #endif
 558          #elif defined REMO_NEC
                bit     RemoPhase=0;
                DATA BYTE RemoStep=0;
                DATA BYTE RemoHcnt, RemoLcnt;
                DATA BYTE RemoData[4];
                  IDATA BYTE  RemoDataReady=0;
                IDATA BYTE  RemoNum, RemoBit;
                  #ifdef DEBUG_REMO_NEC
                    DATA BYTE DebugRemoStep;
                    DATA BYTE DebugRemoHcnt;
                    DATA BYTE   DebugRemoLcnt;
                    DATA BYTE   DebugRemoNum;
                    DATA BYTE   DebugRemoBit;
                    DATA BYTE   DebugRemoPhase;
                    DATA BYTE   DebugRemoDataReady;
                  #endif
              #endif // REMO_RC5 REMO_NEC 
 575              bit   RM_get = 0;
 576          
 577          DATA  WORD    RemoTic=0;
 578          
 579          #ifdef REMO_RC5
 580          #ifdef DEBUG_REMO
              BYTE RemoCapture0[14+1];
              BYTE RemoCapture1[14+1];
              BYTE RemoCapture2[14+1];
              #endif
 585          /**
 586          * timer2 interrupt service routine for remocon
 587          *
 588          * 
 589          * enable  SFR_ET2
 590          *     But, I am using EA, Do NOT USE SFR_ET2. 
 591          * port    P1.4 
 592          *       On TW8836 EVB1.0, it uses INT11(PORT1_4) to activate timer2.
 593          */
 594          void timer2_int(void) interrupt 5 using 1 // suggest: use register block 3
 595          {
 596   1        BYTE  i;
 597   1        bit sample;
 598   1      
 599   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0020;
                INTR_counter[5]++;
              #endif
 603   1      
 604   1        if(g_access==0) {
 605   2          SFR_T2IF &= 0xfc;     // Clear Interrupt Flag
 606   2          return;
 607   2        }
 608   1        SFR_T2IF &= 0xfc;       // Clear Interrupt Flag
 609   1      
 610   1        //read sample
 611   1        sample = REMO_IN;
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 11  

 612   1        RemoTic++;
 613   1      
 614   1      #ifdef DEBUG_REMO
                if(RemoTic==5) {
                  if(RemoCaptureDisable==0)
                    RemoCapture0[0] = 0x0F; //valid 0..4  
                  if(RemoCaptureDisable==1)
                    RemoCapture1[0] = 0x0F; 
                  if(RemoCaptureDisable==2)
                    RemoCapture2[0] = 0x0F; 
                }
              
                i = (RemoTic & 0x07);
                if(RemoTic <= 8*14) {
                  if(sample) {
                    if(RemoCaptureDisable==0)
                      RemoCapture0[RemoTic >> 3] |= (1 << i); 
                    if(RemoCaptureDisable==1)
                      RemoCapture1[RemoTic >> 3] |= (1 << i); 
                    if(RemoCaptureDisable==2)
                      RemoCapture2[RemoTic >> 3] |= (1 << i); 
                  }
                }
              #endif
 636   1      
 637   1        //---------------------------
 638   1        // Note. We starts from RemoTic 4 with RemoPhase1 0.
 639   1        //       At frist time, The RemoTic will be 5, and RemoPhase2 has to be 1.
 640   1        //---------------------------
 641   1        i = RemoTic & 0x07;
 642   1        if     ( i==1 ) RemoPhase1 = sample; //REMO_IN;
 643   1        else if( i==5 ) RemoPhase2 = sample; //REMO_IN;
 644   1        //----- Received 1 Bit -----
 645   1        else if( i==0 ) { //every 8 RemoTic
 646   2          if( RemoPhase1==RemoPhase2 ) {  // error
 647   3            SFRB_ET2=0;
 648   3      
 649   3            ClearRemoTimer();     
 650   3            EnableRemoInt();
 651   3      
 652   3            return;
 653   3          }
 654   2          if( RemoTic<=(8*8) ) {        // SystemCode. Start1+Start2 + Toggle + 5 BIT ADDRESS
 655   3            RemoSystemCode <<=1;
 656   3            if( RemoPhase1==1 && RemoPhase2==0 )
 657   3              RemoSystemCode |=1;
 658   3          }
 659   2          else {                // DataCode.  6 BIT COMMAND
 660   3            RemoDataCode <<=1;
 661   3            if( RemoPhase1==1 && RemoPhase2==0 )
 662   3              RemoDataCode |=1;
 663   3          }
 664   2          //----- Received 1 Packet -----
 665   2          if( RemoTic >= (8*14) ) {
 666   3            RemoDataReady++;        // new key
 667   3      #ifdef DEBUG_REMO
                    if(RemoCaptureDisable==0) {  RemoSystemCode0 = RemoSystemCode; RemoDataCode0 = RemoDataCode; }
                    if(RemoCaptureDisable==1) {  RemoSystemCode1 = RemoSystemCode; RemoDataCode1 = RemoDataCode; }
                    if(RemoCaptureDisable==2) {  RemoSystemCode2 = RemoSystemCode; RemoDataCode2 = RemoDataCode; }
                    RemoCaptureDisable++;
              #endif
 673   3            RemoReceivedTime = SystemClock;
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 12  

 674   3      
 675   3            ClearRemoTimer();       
 676   3          }
 677   2        }
 678   1      }
 679          #endif //..REMO_RC5
 680          #ifdef REMO_NEC
              void timer2_int(void) interrupt 5 using 1 // suggest: use register block 3      
              {
                SFR_T2IF &= 0xfc;     // Clear Interrupt Flag
              
                RemoTic++;
              
                if( RemoDataReady )   
                  return;
              
                switch( RemoStep ) {
                case 0:
                  //wait 9ms.
                  if( REMO_IN==0 ) {
                    RemoLcnt++;
                    if( RemoLcnt==0xff ) //wait 42.38...samples
                      goto RemoError;
                  }
                  else {
                    RemoHcnt = 0;
                    RemoStep++;
                  }
                  break;
              
                case 1:
                  //wait 4.5ms for normal........ wait 24.106 samples
                  //wait 2.25ms for repeat code.. wait 12.053 samples
                  if( REMO_IN==1 ) {
                    RemoHcnt++;
                    if( RemoHcnt==0xff )  //
                      goto RemoError;
                  }
                  else {
                    if( RemoLcnt>=15*3 && RemoLcnt<=17*3 ) {  //target 16*3 = 48
                      
                      if( RemoHcnt>=3*3 && RemoHcnt<=5*3 ) {  //target 4*3 = 12
                        RemoStep = 3;
                        #ifdef DEBUG_REMO_NEC
                        if(DebugRemoStep==0) {
                          DebugRemoStep = RemoStep;
                          DebugRemoLcnt = RemoLcnt;
                          DebugRemoHcnt = RemoHcnt;
                        }
                        #endif
                        RemoDataReady = 2;           //auto repeat..
                        break;
                      }
                      else if( RemoHcnt>=7*3 && RemoHcnt<=9*3 ) { //target 8*3 = 24
                        RemoStep++;               //move to RemoStep 2.
                        #ifdef DEBUG_REMO_NEC
                        if(DebugRemoStep==0) {
                          DebugRemoStep = RemoStep;
                          DebugRemoLcnt = RemoLcnt;
                          DebugRemoHcnt = RemoHcnt;
                        }
                        #endif
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 13  

                        RemoPhase = 0;
                        RemoLcnt = 0;
                        RemoNum  = 0;
                        RemoBit  = 0;
              
                        break;
                      }
                    }
                    else goto RemoError;
                  }
                  break;
              
                case 2:
                  if( RemoPhase==0 ) {
                    if( REMO_IN==0 )          // Phase=0  Input=0
                      RemoLcnt++;
                    else {                // Phase=0  Input=1
                      RemoPhase = 1;
                      RemoHcnt = 0;
                    }
                  }
                  else {                
                    if( REMO_IN==1 )          // Phase=1  Input=1
                      RemoHcnt++;
                    else {                // Phase=1  Input=0
                      RemoPhase = 0;
                      if( RemoLcnt>=1 && RemoLcnt<=5 ) {
                        if( RemoHcnt<=2*3 )       // bit 0
                          RemoData[RemoNum] <<= 1;
                        else if( RemoHcnt<=4*3 ) {    // bit 1
                          RemoData[RemoNum] <<= 1;
                          RemoData[RemoNum]++;
                        }
                        else goto RemoError;
              
                        if( ++RemoBit>=8 ) {
                          RemoBit = 0;
                          if( ++RemoNum>=4 ) {
                            RemoDataReady = 1;
                            RemoStep++;
                          }
                        }
                        RemoLcnt = 0;
              
                      }
                      else goto RemoError;
                    }
                  }
                  break;
              
                case 3:
                  break;
                
                }
                return;
              
              RemoError:
                ClearRemoTimer();
                EnableRemoInt();
              
              }
              #endif  //..REMO_NEC
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 14  

 798          
 799          
 800          
 801          //*****************************************************************************
 802          //      UART 1 Interrupt                                                   
 803          //*****************************************************************************
 804          #ifdef SUPPORT_UART1
              
              DATA  BYTE  RS1_buf[RS_BUF_MAX];
              DATA  BYTE  RS1_in=0, RS1_out=0;
                  bit   RS1_Xbusy=0;
              
              /**
              * UART1 interrupt service routine
              * 
              * If REG04B[6]=1, pin #120,#121 is assigned to #60,#61.
              * enable SFR_ES1
              *
              */
              void uart1_int(void) interrupt 6 using 1
              {
                BYTE  count;
              
              #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0040;
                INTR_counter[6]++;
              #endif
              
                if( SFRB_RI1 ) {            //--- Receive interrupt ----
                  SFRB_RI1 = 0;
                  //if ( SFR_UART1FIFO & 0x80 ) {   // is it use fifo?
                    count = SFR_UART1FIFO & 0x1F;
                    if ( count & 0x10) {
                      SFR_UART1FIFO = 0x90;   // overflowed, buffer clear
                    }
                    else {
                      while (count) {
                        RS1_buf[RS1_in++] = SFR_SBUF1;
                        if( RS1_in>=RS_BUF_MAX ) RS1_in = 0;
                        count--;
                      };
                    }
                  //}
                  //else {
                  //  RS1_buf[RS1_in++] = SFR_SBUF1;
                  //  if( RS1_in >= RS_BUF_MAX ) RS1_in = 0;
                  //}
                }
              
                if( SFRB_TI1 ) {          //--- Transmit interrupt ----
                  SFRB_TI1 = 0;
                  RS1_Xbusy=0;
                }
              }
              #endif
 853          
 854          //*****************************************************************************
 855          //*      Ext Int 2 Interrupt  (Low)         : <<DMA Done>>    P2.2  EXIF0
 856          //*****************************************************************************
 857          /*
 858          *
 859          * enable  SFR_EX1
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 15  

 860          */
 861          void ext2_int(void) interrupt 7 using 1
 862          {
 863   1        BYTE val;
 864   1      
 865   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0080;
                INTR_counter[7]++;
              #endif
 869   1        if(g_access==0)
 870   1          return;
 871   1      
 872   1        val = ReadTW8A(REG002);
 873   1        WriteTW8A(REG002, 0x80);  // Clear Int    
 874   1      }
 875          
 876          //*****************************************************************************
 877          //*      Ext Int 3 Interrupt (Low)            : <<Touch Ready>> P2.3  EXIF1
 878          // enable REG0B1[7]=0 (default)
 879          // status REG0B0[3]
 880          // clear  REG0B0[3]=1
 881          //*****************************************************************************
 882          void ext3_int(void) interrupt 8 using 1
 883          {
 884   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0100;
                INTR_counter[8]++;
              #endif
 888   1      }
 889          //*****************************************************************************
 890          //*      Ext Int 4 Interrupt (Low)            : XRAM 0x7FF access by I2C, reserved    EXIF2
 891          //*****************************************************************************
 892          /*
 893          *
 894          * SFR_EINT4
 895          */
 896          void ext4_int(void) interrupt 9 using 1
 897          {
 898   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0200;
                INTR_counter[9]++;
              #endif
 902   1        ExtIntCount++;
 903   1        INT_STATUS3 = ReadTW8A(REG002) & 0x10;
 904   1        WriteTW8A(REG002, INT_STATUS3);   //clear 
 905   1      
 906   1        //If you want to test, use SFR_EINT4 and skip "SFR_EINT4=1".
 907   1      }
 908          //*****************************************************************************
 909          //*      Ext Int 5 Interrupt (Falling)          : reserved
 910          //*****************************************************************************
 911          void ext5_int(void) interrupt 10 using 1
 912          {
 913   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0400;
                INTR_counter[10]++;
              #endif
 917   1      }
 918          //*****************************************************************************
 919          //*      Ext Int 6 Interrupt (Falling)          : <<Pen Int>> P2.4
 920          //
 921          // enable REG0B1[6]=0 (default)
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 16  

 922          // status REG0B0[4]
 923          // clear  REG0B0[4]=1
 924          // 
 925          //*****************************************************************************
 926          void ext6_int(void) interrupt 11 using 1
 927          {
 928   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x0800;
                INTR_counter[11]++;
              #endif
 932   1      }
 933          //*****************************************************************************
 934          //*      Watchdog Interrupt               : <<Watchdog>>
 935          //*****************************************************************************
 936          //===== WatchDog ======
 937          #ifdef DEBUG_WATCHDOG
                  bit   F_watch=0;
              #endif
 940          
 941          
 942          #pragma SAVE
 943          #pragma OPTIMIZE(8,SPEED)
 944          /**
 945          * watchdog interrupt service routine
 946          * 
 947          *#ifdef DEBUG_WATCHDOG
 948          * only for debug.
 949          *#else
 950          * clear CACHE
 951          *#endif
 952          */
 953          void watchdog_int(void) interrupt 12 using 3
 954          {
 955   1      #ifdef DEBUG_ISR
                MCU_INT_STATUS |= 0x1000;
                INTR_counter[12]++;
              #endif
 959   1      
 960   1      #ifdef DEBUG_WATCHDOG
                F_watch = 1;        //to indicate this interrupt was happen.
                                      //and write RWT.
                SFRB_EA=0;      //Disable Interrupt
                SFR_TA = 0xaa;
                SFR_TA = 0x55;
                SFR_WDCON = 0x03; // - - - - WDIF WTRF EWT RWT..it to clear WDIF.
                SFRB_EA=1;      //Enable Interrupt
              #else
 969   1          /*
 970   1              disable cache & do not write RWT.
 971   1              system will be reset after 512 clock cycle base on 32KHz.
 972   1          */
 973   1          SFR_CACHE_EN=0;
 974   1      #endif
 975   1      }
 976          #pragma RESTORE
 977          
 978          
 979          //*****************************************************************************
 980          //*      Ext Int 7 Interrupt (Programable)        : <<INT 7>>   P1.0
 981          //*****************************************************************************
 982          void ext7_int(void) interrupt 13 using 1
 983          {
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 17  

 984   1        EXINT_STATUS |= 1;
 985   1        ExtIntCount++;
 986   1      #ifdef DEBUG_ISR
                INTR_counter[13]++;
              #endif
 989   1      
 990   1        SFR_E2IF  = 0x01;   // Clear Flag, if Edge triggered
 991   1      }
 992          //*****************************************************************************
 993          //*      Ext Int 8 Interrupt (Programable)        : <<INT 8>>   P1.1
 994          //*****************************************************************************
 995          void ext8_int(void) interrupt 14 using 1
 996          {
 997   1        EXINT_STATUS |= 2;
 998   1      #ifdef DEBUG_ISR
                INTR_counter[14]++;
              #endif
1001   1      
1002   1        SFR_E2IF  = 0x02;   // Clear Flag, if Edge triggered
1003   1      }
1004          //*****************************************************************************
1005          //*      Ext Int 9 Interrupt (Programable)        : <<INT 9>>   P1.2  
1006          //*****************************************************************************
1007          //On TW8836 EVB, pin62(P1.2) is assigned to DTVCLK2.
1008          //and, remocon is assigned on P1.4
1009          void ext9_int(void) interrupt 15 using 1
1010          {
1011   1        EXINT_STATUS |= 4;
1012   1        ExtIntCount++;
1013   1      #ifdef DEBUG_ISR
                INTR_counter[15]++;
              #endif
1016   1      
1017   1        SFR_E2IF  = 0x04;   // Clear Flag, if Edge triggered
1018   1      }
1019          //*****************************************************************************
1020          //*      Ext Int 10 Interrupt (Programable)       : <<INT 10>>  P1.3
1021          //*****************************************************************************
1022          /**
1023          * ext10 interrupt service routine
1024          * 
1025          */
1026          void ext10_int(void) interrupt 16 using 1
1027          {
1028   1        EXINT_STATUS |= 8;
1029   1        ExtIntCount++;
1030   1      #ifdef DEBUG_ISR
                INTR_counter[16]++;
              #endif
1033   1      
1034   1        SFR_E2IF  = 0x08;   // Clear Flag, if Edge triggered
1035   1      
1036   1      }
1037          
1038          //*****************************************************************************
1039          //*      Ext Int 11 Interrupt (Programable)       : <<INT 11>   P1.4  Remocon
1040          //*****************************************************************************
1041          void ext11_int(void) interrupt 17 using 1
1042          {
1043   1        EXINT_STATUS |= 0x10;
1044   1        ExtIntCount++;
1045   1      
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 18  

1046   1      #ifdef DEBUG_ISR
                INTR_counter[17]++;
              #endif
1049   1      
1050   1        DisableRemoInt();
1051   1        SFR_E2IF  = 0x10;   // Clear Flag, if Edge triggered
1052   1      
1053   1        InitRemoTimer();
1054   1      }
1055          //*****************************************************************************
1056          //*      Ext Int 12 Interrupt (Programable)       : <<INT 12>>  P1.5
1057          //*****************************************************************************
1058          // On TW8835, P1.5 was for PowerDown.
1059          void ext12_int(void) interrupt 18 using 1
1060          {
1061   1        EXINT_STATUS |= 0x20;
1062   1      #ifdef DEBUG_ISR
                INTR_counter[18]++;
              #endif
1065   1      
1066   1        SFR_E2IF  = 0x20;   // Clear Flag, if Edge triggered
1067   1      }
1068          //*****************************************************************************
1069          //*      Ext Int 13 Interrupt (Programable)       : <<INT 13>>  P1.6
1070          //*****************************************************************************
1071          void ext13_int(void) interrupt 19 using 1
1072          {
1073   1        EXINT_STATUS |= 0x40;
1074   1      #ifdef DEBUG_ISR
                INTR_counter[19]++;
              #endif
1077   1      
1078   1        SFR_E2IF  = 0x40;   // Clear Flag, if Edge triggered
1079   1      }
1080          
1081          //*****************************************************************************
1082          //*      Ext Int 14 Interrupt (Programable)         : <<INT 14>>  P1.7
1083          //*****************************************************************************
1084          void ext14_int(void) interrupt 20 using 1
1085          {
1086   1        EXINT_STATUS |= 0x80;
1087   1      #ifdef DEBUG_ISR
                INTR_counter[20]++;
              #endif
1090   1      
1091   1        SFR_E2IF  = 0x80;   // Clear Flag, if Edge triggered
1092   1      }
1093          
1094          //*****************************************************************************
1095          
1096          
1097          //=============================================================================
1098          //    Serial RX Check                            
1099          //=============================================================================
1100          /**
1101          * check Serial RX
1102          *
1103          * @return
1104          * 1:something to read.  0:empty.
1105          * 
1106          */
1107          BYTE RS_ready(void)
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 19  

1108          {
1109   1        if( RS_in == RS_out ) return 0;
1110   1        else return 1;
1111   1      }
1112          
1113          #ifdef SUPPORT_UART1
              BYTE RS1_ready(void)
              {
                if( RS1_in == RS1_out ) return 0;
                else return 1;
              }
              #endif
1120          
1121          //=============================================================================
1122          //    Serial RX                              
1123          //=============================================================================
1124          /**
1125          * get Rx data
1126          */
1127          BYTE RS_rx(void)
1128          {
1129   1        BYTE  ret;
1130   1      
1131   1        SFRB_ES = 0;
1132   1      
1133   1        ret = RS_buf[RS_out];
1134   1        RS_out++;
1135   1        if(RS_out >= RS_BUF_MAX) 
1136   1          RS_out = 0;
1137   1      
1138   1        SFRB_ES = 1;
1139   1      
1140   1        return ret;
1141   1      }
1142          #ifdef SUPPORT_UART1
              BYTE RS1_rx(void)
              {
                BYTE  ret;
              
                SFRB_ES1 = 0;
                ret = RS1_buf[RS1_out];
                RS1_out++;
                if(RS1_out >= RS_BUF_MAX) 
                  RS1_out = 0;
                SFRB_ES1 = 1;
              
                return ret;
              }
              #endif
1157          
1158          /**
1159          * unget Rx data
1160          */
1161          void RS_ungetch(BYTE ch)
1162          {
1163   1        SFRB_ES = 0;
1164   1        RS_buf[RS_in++] = ch;
1165   1        if( RS_in>=RS_BUF_MAX ) RS_in = 0;
1166   1        SFRB_ES = 1;
1167   1      }
1168          #ifdef SUPPORT_UART1
              void RS1_ungetch(BYTE ch)
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 20  

              {
                SFRB_ES1 = 0;
                RS1_buf[RS1_in++] = ch;
                if( RS1_in >=RS_BUF_MAX ) RS1_in = 0;
                SFRB_ES1 = 1;
              }
              #endif
1177          
1178          //=============================================================================
1179          //    Serial TX                              
1180          //=============================================================================
1181          /**
1182          * send Tx
1183          */
1184          void RS_tx(BYTE tx_buf)
1185          {
1186   1        while(RS_Xbusy);
1187   1      
1188   1        SFRB_ES = 0;
1189   1        SFR_SBUF = tx_buf;
1190   1        RS_Xbusy=1;
1191   1        SFRB_ES = 1;
1192   1      }
1193          #ifdef SUPPORT_UART1
              void RS1_tx(BYTE tx_buf)
              {
                while(RS1_Xbusy);
              
                SFRB_ES1 = 0;
                SFR_SBUF1 = tx_buf;
                RS1_Xbusy=1;
                SFRB_ES1 = 1;
              }
              #endif
1204          
1205          #ifdef DEBUG_UART
              void DEBUG_dump_uart0(void)
              {
                BYTE i;
                if(UART0_OVERFLOW_counter) {
                  Printf("\n\rUART0 Overflow:%bd",UART0_OVERFLOW_counter);
                  UART0_OVERFLOW_counter = 0;  //clear
                }
                if(UART0_MAX_counter) {
                  Printf("\n\rUART0 Max:%bd",UART0_MAX_counter);
                  UART0_MAX_counter = 0;  //clear
                }
                Printf("\n\rRS_buf[%bd], RS_in:%bd RS_out:%bd",RS_BUF_MAX,RS_in,RS_out);
                for(i=0; i <  RS_BUF_MAX; i++)
                  Printf(" %02bx", RS_buf[i]);
              }
              #endif
1222          
1223          
1224          //=============================================================================
1225          //                               
1226          //=============================================================================
1227          /**
1228          * 1ms delay
1229          *
1230          * tic_pc will be increased every 1 timer0 interrupt that based 1ms.
1231          * tic_pc: 0~0xffff and will not increased after 0xffff.
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 21  

1232          * @param cnt_1ms have to less then 65536. max 65sec delay
1233          *
1234          * tic_pc uses WORD size. It is not an automic. It needs SFRB_EA.
1235          */
1236          void delay1ms(WORD cnt_1ms)
1237          {
1238   1        volatile WORD temp_tic_pc;
1239   1        SFRB_ET0 = 0;
1240   1        tic_pc = 0;               //clear
1241   1        SFRB_ET0 = 1;
1242   1        do {
1243   2          SFRB_ET0=0;
1244   2          temp_tic_pc = tic_pc;       //read
1245   2          SFRB_ET0=1;
1246   2        } while(temp_tic_pc < cnt_1ms);     //compare
1247   1      }
1248          
1249          /**
1250          * 1sec delay
1251          */
1252          void delay1s(WORD cnt_1s, WORD line)
1253          {
1254   1        WORD i;
1255   1        Printf("\n\rWait%ds @%d",cnt_1s,line);
1256   1        for(i=0; i < cnt_1s; i++) {
1257   2          delay1ms(1000);
1258   2        }
1259   1      }
1260          
1261          //=============================================================================
1262          //                            Watchdog                                                   
1263          //=============================================================================
1264          /*
1265          watchdog programming
1266          
1267          1. Select interval value WD1,WD0.
1268          2. Enable watchdog
1269              WDCON.1(EWT):Enable Watchdog Timer.
1270          3. Reset Watchdog before it reach 
1271              WDCON.0(RWT):Reset Watchdog Timer.
1272          
1273          
1274          other watchdog control bits
1275          WDCON.3(WDIF):Watchdog Interrupt flag. This bit is set 512 machine cycle before the watchdog do a system r
             -eset.
1276          WDCON.2(WTRF):Watchdog Reset Has Ocurred. This bit is set when watchdog reset has occured.
1277                      If it was clear, the last reset was not caused by Watchdog.
1278          
1279          Watchdog Interrupt
1280          EIE.5(EWDI):Enable Watchdog Interrupt. 
1281              When this bit is set, an interrupt through vector 63h will be triggered when WDCON.3.
1282          EIP.5(PWDI):Watchdog Interrupt Priority.
1283              When this bit i set, the watchdog interrupt is assigned high priority.
1284              When this bit is clear the watchdog interrupt is assigned low priority.
1285          
1286          Watchdog System Reset
1287          WDCON.2(WTRF) will be 1.
1288          Other WDCON bits becomes 0.
1289          */
1290          #pragma SAVE
1291          #pragma OPTIMIZE(8,SIZE)
1292          
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 22  

1293          #if defined(SUPPORT_WATCHDOG) || defined(DEBUG_WATCHDOG)
1294          /**
1295          * restart watchdog
1296          *
1297          *       MOV TA,#0AAh    ;Execute the Timed Access Protection.
1298          *       MOV TA,#055h    ;code to open the Timed Access window.
1299          *       SETB    RWT     ;Reset the watchdog timer by setting the RWT bit.
1300          */
1301          void RestartWatchdog(void)
1302          {
1303   1        SFRB_EWDI = 0;    // Disable WDT Interrupt
1304   1      
1305   1        SFRB_EA=0;      //Disable Interrupt
1306   1        SFR_TA = 0xaa;
1307   1        SFR_TA = 0x55;
1308   1        SFR_WDCON = 0x03; // - - - - WDIF WTRF EWT RWT.  Reset Watchdog
1309   1        SFRB_EA=1;      //Enable Interrupt
1310   1        
1311   1      #ifdef DEBUG_WATCHDOG
                F_watch = 0;
              #else
1314   1          if(SFR_CACHE_EN==0)
1315   1              SFR_CACHE_EN=1;
1316   1      #endif
1317   1        SFRB_EWDI = 1;    // Enable WDT Interrupt (disable for test)
1318   1      }
1319          
1320          //extern void EE_Increase_Counter_Watchdog(void);
1321          
1322          /**
1323          * enable Watchdog
1324          *
1325          * 27MHz MCU clock with EnableWatchdog(1),
1326          *   type "delay 4340" on TW-Terminal.
1327          */
1328          void EnableWatchdog(BYTE mode)
1329          {
1330   1        Printf("\n\rEnableWatchdog(%bd)",mode);
1331   1        SFRB_EWDI = 0;    // Disable WDT Interrupt
1332   1      
1333   1        /* SFR_CKCON (0x8E) : base 32kHz clock.
1334   1        mode WD[1:0]  CLK(on TW8836B) CLK(on FPGA)  Delay
1335   1        3 00      2^11      2^17      70mSec
1336   1        2 01      2^14      2^20      540msec
1337   1        1 10      2^17      2^23      4 sec
1338   1        0 11      2^20      2^26      32 sec
1339   1        */
1340   1        SFR_CKCON &= 0x3F;
1341   1        switch(mode) {
1342   2        case 0:   SFR_CKCON |= 0xc0;  break;  
1343   2        case 1:   SFR_CKCON |= 0x80;  break;  
1344   2        case 2:   SFR_CKCON |= 0x40;  break;  
1345   2        case 3:   SFR_CKCON |= 0x00;  break;  
1346   2        default:  SFR_CKCON |= 0xc0;  break;
1347   2        }
1348   1        SFRB_EA=0;      //Disable Interrupt
1349   1        SFR_TA = 0xaa;
1350   1        SFR_TA = 0x55;
1351   1        SFR_WDCON = 0x03; // - - - - WDIF WTRF EWT RWT.
1352   1        SFRB_EA=1;      //Enable Interrupt
1353   1      
1354   1        SFR_EIP |= 0x20;  // BK160208:We have 512 counter, is it enough ?
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 23  

1355   1        SFRB_EWDI = 1;    // Enable WDT Interrupt (disable for test)
1356   1      
1357   1      #ifdef DEBUG_WATCHDOG
                F_watch = 1; //for first  wdt_last value
              #endif
1360   1      }
1361          
1362          /*
1363          Note: See the OK and NG code. If you use OPTIMIZE(9,), the compiler made a NG code.
1364          OK:
1365            MOV     SFR_TA,#0AAH
1366            MOV     SFR_TA,#055H
1367            MOV     SFR_WDCON,#00H
1368            SETB    SFR_EWDI
1369          
1370          NG:
1371            MOV     SFR_TA,#0AAH
1372            MOV     SFR_TA,#055H
1373            CLR     A
1374            MOV     SFR_WDCON,A
1375            CLR     SFR_EWDI
1376          */
1377          
1378          /**
1379          * disable watchdog
1380          */
1381          void DisableWatchdog(void)
1382          {
1383   1        SFRB_EWDI = 0;    // Disable WDT Interrupt
1384   1      
1385   1        SFRB_EA=0;      //Disable Interrupt
1386   1        SFR_TA = 0xaa;
1387   1        SFR_TA = 0x55;
1388   1        SFR_WDCON = 0x00; // - - - - WDIF WTRF EWT RWT
1389   1        SFRB_EA=1;      //Enable Interrupt
1390   1      
1391   1        Puts("DisableWatchdog\n");
1392   1      }
1393          #pragma RESTORE
1394          #endif //..defined(SUPPORT_WATCHDOG) || defined(DEBUG_WATCHDOG)
1395          
1396          /**
1397          * enable external interrupt
1398          */
1399          void EnableExtInterrupt(BYTE intrn)
1400          {
1401   1        SFR_E2IE |= (1 << intrn); 
1402   1      }
1403          /**
1404          * disable externel interrupt
1405          */
1406          void DisableExtInterrupt(BYTE intrn)
1407          {
1408   1        SFR_E2IE &= ~(1 << intrn);  
1409   1      }
1410          
1411          
1412          //=============================================================================
1413          //      Remocon
1414          //=============================================================================
1415          
1416          
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 24  

1417          
1418          //On TW8835, it was use P1_2<<INT9>>.
1419          //On TW8836, FW using P1.4<<INT11>>.
1420          #ifdef REMO_RC5
1421          
1422          /**
1423          * init remocon timer
1424          */
1425          void InitRemoTimer(void)
1426          {
1427   1      #ifdef DEBUG_REMO
                BYTE i;
              #endif
1430   1      
1431   1        ClearRemoTimer();     //T2CON = 0x00;       // 
1432   1         
1433   1        SFRB_ET2  = 0;        // Disable Timer2 Interrupt
1434   1        SFR_T2IF = 0x00;      // Clear Flag
1435   1      
1436   1                      // Reload Value
1437   1        SFR_RCRH = SFR_TH2 = 0xff;  // 0xFF2E = 0x10000-0xD2 = 0x10000-210. 
1438   1        SFR_RCRL = SFR_TL2 = 0x2e;  // it means 210 usec interval. 
1439   1      
1440   1        SFR_RCRL = SFR_TL2 = 0x2D;    
1441   1                      //RC5 uses 14 bytes.
1442   1                      //RC5 spec uses a 24892us for 14 byte.
1443   1                      //TW8835 use a 8 sampling per one bit 
1444   1                      //If remocon use a 24892us for 14 Bytes, we have to assign 222us interval.
1445   1                      // 
1446   1                      //When I measure a data1 signal from the first falling edge to the last up edge, it was 22800us.
1447   1                      //and it starts from first falling edge.
1448   1                      // 22800us = (14*8-4) * interval. 
1449   1                      // the best interval value is 211us.
1450   1      
1451   1      
1452   1        SFR_T2CON = 0x12;     // 0001 0010 
1453   1                      // |||| |||+-- T2I0 \ Timer2 Input Selection 
1454   1                      // |||| ||+--- T2I1 / 00=No,  01=Timer,  10=Counter, 11=Gate
1455   1                      // |||| |+---- T2CM:  Compare mode
1456   1                      // |||| +----- T2R0 \ Timer2 Reload Mode 
1457   1                      // |||+------- T2R1 / 00=No,  01=No,     10=Auto,    11=pin T2EX
1458   1                      // ||+-------- ---
1459   1                      // |+--------- I3FR: Timer2 Compare0 Interrupt Edge...
1460   1                      // +---------- T2PS: Timer2 Prescaler
1461   1      
1462   1        //start from...
1463   1        RemoTic = 4;
1464   1        RemoPhase1 = 1;
1465   1      
1466   1      #ifdef DEBUG_REMO
                if(RemoCaptureDisable==0) {
                  for(i=0; i <= 14; i++) {
                    RemoCapture0[i]=0x00;
                    RemoCapture1[i]=0x00;
                    RemoCapture2[i]=0x00;
                  }
                }
              #endif
1475   1        //BKFYI.
1476   1        //the next timer2 ISR will be RemoTic 5, and ISR will capture the sample RemoPhase2.
1477   1        //The RemoPhase2 have to be 0 in our system(Active Low). 
1478   1      
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 25  

1479   1        RemoSystemCode = 0;
1480   1        RemoDataCode = 0;
1481   1      
1482   1        SFRB_ET2  = 1;          // Enable Timer 2 Interrupt
1483   1      }
1484          
1485          #elif defined REMO_NEC
              
              void InitRemoTimer(void)
              {
                WORD temp;
              
                ClearRemoTimer();     //T2CON = 0x00; 
                 
                ET2  = 0;         // Disable Timer2 Interrupt
                T2IF = 0x00;        // Clear Flag
              
                              //need 186.667us 
                temp = 0x10000 - 187;     //or 186  0x10000- BA. 186.667uS  
              
                CRCH = TH2 = temp>>8;
                CRCL = TL2 = (BYTE)(temp & 0xff);
              
                T2CON = 0x12;       // 0001 0010 
                              // |||| |||+-- T2I0 \ Timer2 Input Selection 
                              // |||| ||+--- T2I1 / 00=No,  01=Timer,  10=Counter, 11=Gate
                              // |||| |+---- T2CM:  Compare mode
                              // |||| +----- T2R0 \ Timer2 Reload Mode 
                              // |||+------- T2R1 / 00=No,  01=No,     10=Auto,    11=pin T2EX
                              // ||+-------- ---
                              // |+--------- I3FR: Timer2 Compare0 Interrupt Edge...
                              // +---------- T2PS: Timer2 Prescaler
              
              
                RemoTic = 0;    //tm01 = 0;
                RemoStep  = 0;
                RemoPhase = 0;
                RemoHcnt  = 0;
                RemoLcnt  = 0;
              
                ET2  = 1;         // Enable Timer 2 Interrupt
              }
              #endif
1522          
1523          //=============================================================================
1524          //                            Initialize CPU                                                   
1525          //=============================================================================
1526          /**
1527          * initialize MCU(DP80390)
1528          */
1529          void init_cpu(BYTE fWatchDog)
1530          {
1531   1      #ifdef DEBUG_ISR
                BYTE i;
              #endif
1534   1      
1535   1        TWBASE = 0x00;          // Base address of TW88xx
1536   1        SFR_CAMC = 1;         // Chip Access Mode Control. E2[0]=1b:16bit mode
1537   1      
1538   1          if(!fWatchDog) {
1539   2            //---------- Initialize Timer Divider ---------
1540   2            WriteTW88(REG4E2, 0x69);    // Timer0 Divider : system tic 0. 
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 26  

1541   2            WriteTW88(REG4E3, 0x78);    // 27M/27000 = 1msec
1542   2          
1543   2            WriteTW88(REG4E4, 0x01);    // Timer1 Divider : for Touch
1544   2            WriteTW88(REG4E5, 0x0e);    // 27M/270 = 10usec 
1545   2          
1546   2            WriteTW88(REG4E6, 0);     // Timer2 Divider : remo timer
1547   2            WriteTW88(REG4E7, 0x1b);    // 27M/27 = 1usec
1548   2          
1549   2            WriteTW88(REG4E8, 0);     // Timer3 Divider : baudrate for UART0
1550   2            WriteTW88(REG4E9, 0x0c);    // (22.1184M *2 /32) / 12 = 115200bps on SM0=1 & SMOD0=1  
1551   2          
1552   2            WriteTW88(REG4EA, 0);     // Timer4 Divider : baudrate for UART1
1553   2            WriteTW88(REG4EB, 0x0c);    // (22.1184M *2 /32) / 12 = 115200bps on SM1=1 & SMOD1=1  
1554   2          
1555   2            /*If you want the UART1 swap, add below code. */
1556   2            /* WriteTW88(REG04B, ReadTW88(REG04B) | 0x40);  */
1557   2          }
1558   1      #ifdef DEBUG_ISR
                for(i=0; i < 21; i++)
                  INTR_counter[i]=0;
              #endif
1562   1      
1563   1        //---------- Initialize interrupt -------------
1564   1        SFR_CKCON = 0x00;   // Clock control register     
1565   1                    // 0000 0000
1566   1                    // |||| |||+-- MD0 \.
1567   1                    // |||| ||+--- MD1  > MD[2:0] Stretch RD/WR timing
1568   1                    // |||| |+---- MD2 /
1569   1                    // |||| +----- T0M:  Timer0 Pre-Divider 0=div by 12,  1=div by 4
1570   1                    // |||+------- T1M:  Timer1 Pre-Divider 0=div by 12,  1=div by 4
1571   1                    // ||+-------- ---
1572   1                    // |+--------- WD0 \ Watchdong Timeout Period
1573   1                    // +---------- WD1 / 00=2^17,  01=2^20,  10=2^23,  11=2^26
1574   1      
1575   1          SFR_TMOD = 0x66;    // 0110 0110
1576   1                    // |||| ||||   << Timer 0 >>
1577   1                    // |||| |||+-- M0 \  00= 8bit timer,counter /32  01= 16bit timer,counter
1578   1                    // |||| ||+--- M1 /  10= 8bit auto reload        11= 8bit timer,counter
1579   1                    // |||| |+---- CT:   0=Timer Mode,    1=Counter Mode
1580   1                    // |||| +----- GATE: 0=GATE not used, 1=GATE used
1581   1                    // ||||        << Timer 1 >>
1582   1                    // |||+------- M0 \  00= 8bit timer,counter /32  01= 16bit timer,counter
1583   1                    // ||+-------- M1 /  10= 8bit auto reload        11= 8bit timer,counter
1584   1                    // |+--------- CT:   0=Timer Mode,    1=Counter Mode
1585   1                    // +---------- GATE: 0=GATE not used, 1=GATE used
1586   1      
1587   1          SFR_TCON = 0x55;    // 0101 0101
1588   1                    // |||| |||+-- IT0:  INT0 Trigger 0=level, 1=edge
1589   1                    // |||| ||+--- IE0:  INT0 Interrupt Flag
1590   1                    // |||| |+---- IT1:  INT1 Trigger 0=level, 1=edge
1591   1                    // |||| +----- IE1:  INT1 Interrupt Flag
1592   1                    // |||+------- TR0:  Timer0 Run
1593   1                    // ||+-------- TF0:  Timer0 Flag
1594   1                    // |+--------- TR1:  Timer1 Run
1595   1                    // +---------- TF0:  Timer1 Flag
1596   1      
1597   1        SFR_TH0 = 0xff;     // 0xFFFF = 0x10000-1 = 1 msec
1598   1        SFR_TL0 = 0xff;     //
1599   1      
1600   1                    // for TOUCH SAR sensing timer
1601   1        SFR_TH1 = 206;      // 
1602   1                    // TH1 = 156. 1ms
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 27  

1603   1                    // TH1 = 206. 0.5ms = 50*10usec
1604   1      
1605   1        SFR_T2CON = 0x12;   // 0001 0010 
1606   1                    // |||| |||+-- T2I0 \ Timer2 Input Selection 
1607   1                    // |||| ||+--- T2I1 / 00=No,  01=Timer,  10=Counter, 11=Gate
1608   1                    // |||| |+---- T2CM:  Compare mode
1609   1                    // |||| +----- T2R0 \ Timer2 Reload Mode 
1610   1                    // |||+------- T2R1 / 00=No,  01=No,     10=Auto,    11=pin T2EX
1611   1                    // ||+-------- ---
1612   1                    // |+--------- I3FR: Timer2 Compare0 Interrupt Edge...
1613   1                    // +---------- T2PS: Timer2 Prescaler
1614   1              
1615   1        SFR_TH2 = 0xff;         // 0xFF2E = 0x10000-0xD2 = 0x10000-210. 
1616   1        SFR_TL2 = 0x2e;         // it means 210 usec interval. 
1617   1      
1618   1        SFR_PCON = 0xc0;    // 1100 0000
1619   1                    // |||| |||+-- PMM:  Power Management Mode 0=Disable,  1=Enable
1620   1                    // |||| ||+--- STOP: Stop Mode             0=Disable,  1=Enable
1621   1                    // |||| |+---- SWB:  Switch Back from STOP 0=Disable,  1=Enable
1622   1                    // |||| +----- ---
1623   1                    // |||+------- PWE:  (Program write Enable)
1624   1                    // ||+-------- ---
1625   1                    // |+--------- SMOD1:UART1 Double baudrate bit
1626   1                    // +---------- SMOD0:UART0 Double baudrate bit
1627   1      
1628   1        SFR_SCON = 0x50;    // 0101 0000
1629   1                    // |||| |||+-- RI:   Receive Interrupt Flag
1630   1                    // |||| ||+--- TI:   Transmit Interrupt Flag
1631   1                    // |||| |+---- RB08: 9th RX data
1632   1                    // |||| +----- TB08: 9th TX data
1633   1                    // |||+------- REN:  Enable Serial Reception
1634   1                    // ||+-------- SMO2: Enable Multiprocessor communication
1635   1                    // |+--------- SM01 \   Baudrate Mode
1636   1                    // +---------- SM00 / 00=f/12,  01=8bit var,  10=9bit,f/32,f/64,  11=9bit var
1637   1      
1638   1        SFR_SCON1 = 0x50;   // 0101 0000
1639   1                    // |||| |||+-- RI:   Receive Interrupt Flag
1640   1                    // |||| ||+--- TI:   Transmit Interrupt Flag
1641   1                    // |||| |+---- RB08: 9th RX data
1642   1                    // |||| +----- TB08: 9th TX data
1643   1                    // |||+------- REN:  Enable Serial Reception
1644   1                    // ||+-------- SMO2: Enable Multiprocessor communication
1645   1                    // |+--------- SM11 \   Baudrate Mode
1646   1                    // +---------- SM10 / 00=f/12,  01=8bit var,  10=9bit,f/32,f/64,  11=9bit var
1647   1      
1648   1        //---------- Enable Individual Interrupt ----------
1649   1        SFR_IP   = 0x10;    // 0001 0000 interrupt priority
1650   1                                  // |||| |||+-- PX0 EX0
1651   1                                  // |||| ||+--- RT0 ET0
1652   1                                  // |||| |+---- PX1 EX1
1653   1                                  // |||| +----- PT1 ET1
1654   1                                  // |||+------- PS  ES (use register bank 2)
1655   1                                  // ||+-------- PT2 ET2
1656   1                                  // |+--------- PS1 ES1
1657   1                                  // +---------- unused           
1658   1      
1659   1        SFR_IE   = 0x12;    // 1001 0010 interrupt enable
1660   1                                  // |||| |||+ EX0    : Chip Interrupt. I will enable it later.
1661   1                                  // |||| ||+- ET0    : Timer0    System Tic
1662   1                                  // |||| |+-- EX1    : DE End
1663   1                                  // |||| +--- ET1    : timer1 - touch
1664   1                                  // |||+----- ES     : UART0
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 28  

1665   1                                  // ||+------ ET2    : timer2 - remocon
1666   1                                  // |+------- ES1    : UART1
1667   1                                  // +-------- EA     : Global Interrupt. I will enable it below.
1668   1      #ifdef SUPPORT_UART1
                SFRB_ES1  = 1;      // UART1    : External MCU
              #endif
1671   1        //---------- Serial FIFO ----------
1672   1        SFR_UART0FIFO = 0x80; //          : UART0 FIFO
1673   1      #ifdef SUPPORT_UART1
                SFR_UART1FIFO = 0x80; //          : UART1 FIFO
              #endif
1676   1        //---------- Enable global Interrupt ----------
1677   1        SFRB_EA   = 1;      // Global Interrupt
1678   1      
1679   1      
1680   1        //---------- Extended Interrupt -------------------
1681   1        SFR_EIE  = 0x04;    // 0000 0100 extended interrupt enable
1682   1                                  // |||| |||+ EINT2  : SPI-DMA done
1683   1                                  // |||| ||+- EINT3  : Touch Ready
1684   1                                  // |||| |+-- EINT4  : SW 7FF 
1685   1                                  // |||| +--- EINT5  : reserved
1686   1                                  // |||+----- EINT6  : Pen
1687   1                                  // ||+------ EWDI   : Watchdog
1688   1                                  // |+------- reserved
1689   1                                  // +-------- reserved
1690   1          SFR_EIP  = 0x00;
1691   1                                  /* If Watchdog, EIE.5 & EIP.5 will be 1. */
1692   1        //---------- Extended2 Interrupt 7~14 Config. ---------------
1693   1                                  // xxxx xxxx
1694   1                                  // |||| |||+- EINT7
1695   1                                  // |||| ||+-- EINT8
1696   1                                  // |||| |+--- EINT9  :Remocon. SW will enable 9 later.
1697   1                                  // |||| +---- EINT10 :MODEL_TW8835_EXTI2C. VideoISR.
1698   1                                  // |||+------ EINT11
1699   1                                  // ||+------- EINT12
1700   1                                  // |+-------- EINT13
1701   1                                  // +--------- EINT14
1702   1                    // 
1703   1          //SFR_E2IF  = 0x00;   // (0xFA) 0000 0000 : Interrupt Flag         
1704   1        SFR_E2IE  = 0x00;   // (0xFB) 0000 0000 : Interrupt Enable.
1705   1        SFR_E2IP  = 0x00;   // (0xFC) 0000 0000 : Interrupt Priority
1706   1        SFR_E2IM  = 0xff;   // (0xFD) 0000 0000 : Interrupt Mode(0=Level, 1=Edge)
1707   1        SFR_E2IT  = 0x00;   // (0xFE) 0000 0000 : Level/Edge Polarity  (0=Low/Falling, 1=High/Rising)
1708   1                    /*                      0: Low Level,  Falling Edge */
1709   1                    /*                      1: High Level, Rising Edge */
1710   1      
1711   1        Puts("\n\n");
1712   1        Puts("init_cpu");
1713   1        if(SFR_WDCON & 0x04) 
1714   1              Puts(" WTRF");   //<--SFRB_WTRF
1715   1        Puts("\n");
1716   1      
1717   1        /* BKFYI:
1718   1          TW8836B2 always use 16bit access.
1719   1          If you want to check, use below code.
1720   1      
1721   1        if(SFR_CAMC==1)
1722   1          Puts("16Bit Access");
1723   1        */
1724   1      
1725   1        //------- Remote Controller (EINT11, Timer2) --------
1726   1      
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 29  

1727   1        //ClearRemoTimer. RemoINTR(EINT9) will be activateed in RemoTimer   
1728   1      
1729   1        /* BKFYI:
1730   1          The cache enable routine is moved to InitCore.
1731   1        */
1732   1      }
1733          
1734          
1735          
1736          //=============================================================================
1737          //    Time
1738          //=============================================================================
1739          #ifdef SUPPORT_FOSD_MENU
              DATA  BYTE  SleepTimer;
              DATA  WORD  SleepTime;
              #define _24H_SECS     86400L      // 24*60*60
              
              WORD DiffTime_ms( WORD stime, WORD etime )
              {
                if( etime < stime ) {     // resetted
                  return etime + (6000 - stime);
                }
                else {
                  return etime - stime;
                }
              }
              
              WORD GetTime_ms(void)
              {
                WORD tms;
              
                tms = tic01;
                tms += ( SystemClock * 1000 );
                return tms; // in ms
              }
              BYTE GetTime_H(void)
              {
                return ( SystemClock / 60 / 60 ) % 24 ;
              }
              BYTE GetTime_M(void)
              {
                return ( SystemClock / 60  ) % 60 ;
              }
              BYTE GetSleepTimer(void)
              {
                WORD val;
              
                val = SleepTimer;
                if( val ) { // already set, display rest of time
                  val = ( SleepTime >> 8 ) * 60 + ( SleepTime & 0xff );
                  val -= ( GetTime_H() * 60 + GetTime_M() );
                }
                return (BYTE)val;
              }
              void SetSleepTimer(BYTE stime)
              {
                SleepTimer = stime;
                if( SleepTimer==0 )
                  SleepTime = 0xffff;
                else {
                  SleepTime = GetTime_H() + ( GetTime_M() + SleepTimer ) / 60;
                  SleepTime = ( SleepTime << 8 ) | ( ( GetTime_M() + SleepTimer ) % 60 );
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 30  

                }
              
                #ifdef DEBUG_TIME
                dPrintf("\n\rSetSleepTimer(SleepTime:0x%bx)", SleepTime);
                #endif
              }
              #endif
1796          
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 31  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com008F (BEGIN)
0000         L?0144:
0000         L?0145:
0000 759300      E     MOV     DPX,#?C?XDATASEG
0003 E500        R     MOV     A,regTW88+01H
0005 24B2              ADD     A,#0B2H
0007 F582              MOV     DPL,A
0009 E4                CLR     A
000A 3500        R     ADDC    A,regTW88
000C F583              MOV     DPH,A
000E 759300      E     MOV     DPX,#?C?XDATASEG
0011 E0                MOVX    A,@DPTR
0012 7A00              MOV     R2,#00H
0014 C4                SWAP    A
0015 F8                MOV     R0,A
0016 540F              ANL     A,#0FH
0018 C8                XCH     A,R0
0019 68                XRL     A,R0
001A FB                MOV     R3,A
001B EA                MOV     A,R2
001C C4                SWAP    A
001D 54F0              ANL     A,#0F0H
001F 48                ORL     A,R0
0020 FA                MOV     R2,A
0021 759300      E     MOV     DPX,#?C?XDATASEG
0024 E500        R     MOV     A,regTW88+01H
0026 24B3              ADD     A,#0B3H
0028         L?0146:
0028 F582              MOV     DPL,A
002A E4                CLR     A
002B 3500        R     ADDC    A,regTW88
002D F583              MOV     DPH,A
002F 759300      E     MOV     DPX,#?C?XDATASEG
0032 22                RET     
0033         L?0147:
0033         L?0148:
0033 90000000    R     MOV     DPTR,#ExtIntCount
0037 E0                MOVX    A,@DPTR
0038 FC                MOV     R4,A
0039 A3                INC     DPTR
003A E0                MOVX    A,@DPTR
003B FD                MOV     R5,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FE                MOV     R6,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 2401              ADD     A,#01H
0043 FF                MOV     R7,A
0044 E4                CLR     A
0045 3E                ADDC    A,R6
0046 FE                MOV     R6,A
0047 E4                CLR     A
0048 3D                ADDC    A,R5
0049 FD                MOV     R5,A
004A E4                CLR     A
004B 3C                ADDC    A,R4
004C FC                MOV     R4,A
004D 90000000    R     MOV     DPTR,#ExtIntCount
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 32  

0051 010000      E     AJMP    ?C?LSTXDATA
0054         L?0149:
0054         L?0150:
0054 C3                CLR     C
0055 90000000    R     MOV     DPTR,#temp+01H
0059 E0                MOVX    A,@DPTR
005A 9B                SUBB    A,R3
005B FE                MOV     R6,A
005C 90000000    R     MOV     DPTR,#temp
0060 E0                MOVX    A,@DPTR
0061 9A                SUBB    A,R2
0062         L?0151:
0062 90000000    R     MOV     DPTR,#diff
0066 F0                MOVX    @DPTR,A
0067 A3                INC     DPTR
0068 22                RET     
0069         L?0152:
0069         L?0153:
0069 F582              MOV     DPL,A
006B E500        R     MOV     A,regTW88
006D 3404              ADDC    A,#04H
006F F583              MOV     DPH,A
0071 759300      E     MOV     DPX,#?C?XDATASEG
0074 22                RET     
0075         L?0154:
0075         L?0155:
0075 E0                MOVX    A,@DPTR
0076 2B                ADD     A,R3
0077 FB                MOV     R3,A
0078 E4                CLR     A
0079 3A                ADDC    A,R2
007A FA                MOV     R2,A
007B 90000000    R     MOV     DPTR,#temp
007F E0                MOVX    A,@DPTR
0080 FE                MOV     R6,A
0081 A3                INC     DPTR
0082 E0                MOVX    A,@DPTR
0083 FF                MOV     R7,A
0084 C3                CLR     C
0085 9B                SUBB    A,R3
0086 EE                MOV     A,R6
0087 9A                SUBB    A,R2
0088 22                RET     
0089         L?0156:
0089         L?0157:
0089 850082      R     MOV     DPL,regTW88+01H
008C 850083      R     MOV     DPH,regTW88
008F 759300      E     MOV     DPX,#?C?XDATASEG
0092 A3                INC     DPTR
0093 A3                INC     DPTR
0094 22                RET     
0095         L?0158:
0095         L?0159:
0095 C3                CLR     C
0096 90000000    R     MOV     DPTR,#diff+01H
009A E0                MOVX    A,@DPTR
009B 940A              SUBB    A,#0AH
009D 90000000    R     MOV     DPTR,#diff
00A1 E0                MOVX    A,@DPTR
00A2 9400              SUBB    A,#00H
00A4 22                RET     
00A5         L?0160:
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 33  

00A5         L?0161:
00A5 F0                MOVX    @DPTR,A
00A6 90000000    R     MOV     DPTR,#CpuTouchStep
00AA E0                MOVX    A,@DPTR
00AB 04                INC     A
00AC F0                MOVX    @DPTR,A
00AD         L?0162:
00AD 90000000    R     MOV     DPTR,#temp
00B1 E4                CLR     A
00B2 F0                MOVX    @DPTR,A
00B3 A3                INC     DPTR
00B4 F0                MOVX    @DPTR,A
00B5 22                RET     
00B6         L?0163:
00B6         L?0164:
00B6 E4                CLR     A
00B7         L?0165:
00B7 F0                MOVX    @DPTR,A
00B8 759300      E     MOV     DPX,#?C?XDATASEG
00BB E500        R     MOV     A,regTW88+01H
00BD 22                RET     
00BE         L?0166:
00BE         L?0167:
00BE 759300      E     MOV     DPX,#?C?XDATASEG
00C1 E500        R     MOV     A,regTW88+01H
00C3 24B0              ADD     A,#0B0H
00C5 22                RET     
00C6         L?0168:
00C6         L?0169:
00C6 C3                CLR     C
00C7 EB                MOV     A,R3
00C8 9F                SUBB    A,R7
00C9 FF                MOV     R7,A
00CA EA                MOV     A,R2
00CB 9E                SUBB    A,R6
00CC 22                RET     
             ; FUNCTION Com008F (END)

             ; FUNCTION ext0_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C093              PUSH    DPX
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D010            MOV     PSW,#010H
                                           ; SOURCE LINE # 196
                                           ; SOURCE LINE # 203
000D 300048            JNB     g_access,?C0002
0010         ?C0001:
                                           ; SOURCE LINE # 207
0010 110000      R     ACALL   L?0156
0013 E0                MOVX    A,@DPTR
0014 54EF              ANL     A,#0EFH
0016 F500        R     MOV     INT_STATUS,A
                                           ; SOURCE LINE # 208
0018 110000      R     ACALL   L?0156
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D F500        R     MOV     INT_MASK,A
                                           ; SOURCE LINE # 209
001F 759300      E     MOV     DPX,#?C?XDATASEG
0022 E500        R     MOV     A,regTW88+01H
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 34  

0024 2404              ADD     A,#04H
0026 110000      R     ACALL   L?0146
0029 E0                MOVX    A,@DPTR
002A F500        R     MOV     INT_STATUS2,A
                                           ; SOURCE LINE # 211
002C 110000      R     ACALL   L?0157
002F E500        R     MOV     A,INT_STATUS
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 212
0032 E500        R     MOV     A,INT_STATUS2
0034 5407              ANL     A,#07H
0036 FF                MOV     R7,A
0037 759300      E     MOV     DPX,#?C?XDATASEG
003A E500        R     MOV     A,regTW88+01H
003C 2404              ADD     A,#04H
003E 110000      R     ACALL   L?0146
0041 EF                MOV     A,R7
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 214
0043 E500        R     MOV     A,INT_STATUS
0045 30E108            JNB     ACC.1,?C0003
                                           ; SOURCE LINE # 215
0048 0500        R     INC     VH_Loss_Changed+01H
004A E500        R     MOV     A,VH_Loss_Changed+01H
004C 7002              JNZ     ?C0121
004E 0500        R     INC     VH_Loss_Changed
0050         ?C0121:
0050         ?C0003:
                                           ; SOURCE LINE # 218
0050 E500        R     MOV     A,INT_STATUS
0052 4200        R     ORL     INT_STATUS_ACC,A
                                           ; SOURCE LINE # 219
0054 E500        R     MOV     A,INT_STATUS2
0056 4200        R     ORL     INT_STATUS2_ACC,A
                                           ; SOURCE LINE # 220
0058         ?C0002:
0058 D0D0              POP     PSW
005A D082              POP     DPL
005C D083              POP     DPH
005E D093              POP     DPX
0060 D0E0              POP     ACC
0062 32                RETI    
             ; FUNCTION ext0_int (END)

             ; FUNCTION timer0_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C0D0              PUSH    PSW
0006 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 244
                                           ; SOURCE LINE # 251
0009 0500        R     INC     tic01
                                           ; SOURCE LINE # 252
000B E500        R     MOV     A,tic01
000D 75F00A            MOV     B,#0AH
0010 84                DIV     AB
0011 85F000      R     MOV     tic01,B
                                           ; SOURCE LINE # 253
0014 E500        R     MOV     A,tic01
0016 7037              JNZ     ?C0004
                                           ; SOURCE LINE # 254
0018 E500        R     MOV     A,SystemClock+03H
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 35  

001A 2401              ADD     A,#01H
001C F500        R     MOV     SystemClock+03H,A
001E E4                CLR     A
001F 3500        R     ADDC    A,SystemClock+02H
0021 F500        R     MOV     SystemClock+02H,A
0023 E4                CLR     A
0024 3500        R     ADDC    A,SystemClock+01H
0026 F500        R     MOV     SystemClock+01H,A
0028 E4                CLR     A
0029 3500        R     ADDC    A,SystemClock
002B F500        R     MOV     SystemClock,A
                                           ; SOURCE LINE # 255
002D AF00        R     MOV     R7,OsdTimerClock+03H
002F AE00        R     MOV     R6,OsdTimerClock+02H
0031 AD00        R     MOV     R5,OsdTimerClock+01H
0033 AC00        R     MOV     R4,OsdTimerClock
0035 EC                MOV     A,R4
0036 4D                ORL     A,R5
0037 4E                ORL     A,R6
0038 4F                ORL     A,R7
0039 6014              JZ      ?C0004
                                           ; SOURCE LINE # 256
003B EF                MOV     A,R7
003C 24FF              ADD     A,#0FFH
003E F500        R     MOV     OsdTimerClock+03H,A
0040 EE                MOV     A,R6
0041 34FF              ADDC    A,#0FFH
0043 F500        R     MOV     OsdTimerClock+02H,A
0045 ED                MOV     A,R5
0046 34FF              ADDC    A,#0FFH
0048 F500        R     MOV     OsdTimerClock+01H,A
004A EC                MOV     A,R4
004B 34FF              ADDC    A,#0FFH
004D F500        R     MOV     OsdTimerClock,A
                                           ; SOURCE LINE # 257
004F         ?C0004:
                                           ; SOURCE LINE # 258
004F 0500        R     INC     tic_pc+01H
0051 E500        R     MOV     A,tic_pc+01H
0053 7002              JNZ     ?C0122
0055 0500        R     INC     tic_pc
0057         ?C0122:
                                           ; SOURCE LINE # 259
0057 0500        R     INC     tic_task+01H
0059 E500        R     MOV     A,tic_task+01H
005B 7002              JNZ     ?C0123
005D 0500        R     INC     tic_task
005F         ?C0123:
                                           ; SOURCE LINE # 260
005F E500        R     MOV     A,tic_timer
0061 6002              JZ      ?C0007
                                           ; SOURCE LINE # 261
0063 1500        R     DEC     tic_timer
                                           ; SOURCE LINE # 262
0065         ?C0007:
0065 D0D0              POP     PSW
0067 D0F0              POP     B
0069 D0E0              POP     ACC
006B 32                RETI    
             ; FUNCTION timer0_int (END)

             ; FUNCTION ext1_int (BEGIN)
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 36  

0000 C0E0              PUSH    ACC
0002 C093              PUSH    DPX
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 287
0008 90000000    R     MOV     DPTR,#ext1_intr_flag
000C 7401              MOV     A,#01H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 288
000F C2AA              CLR     SFRB_EX1
                                           ; SOURCE LINE # 289
0011 D082              POP     DPL
0013 D083              POP     DPH
0015 D093              POP     DPX
0017 D0E0              POP     ACC
0019 32                RETI    
             ; FUNCTION ext1_int (END)

             ; FUNCTION timer1_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C093              PUSH    DPX
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C0D0              PUSH    PSW
000A 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 323
;---- Variable 'TscData' assigned to Register 'R2/R3' ----
                                           ; SOURCE LINE # 335
000D 200003      E     JB      g_access,$ + 6H
0010 010000      R     AJMP    ?C0010
0013         ?C0009:
                                           ; SOURCE LINE # 338
0013 90000000    R     MOV     DPTR,#CpuTouchSkipCount
0017 E0                MOVX    A,@DPTR
0018 7002              JNZ     ?C0124
001A A3                INC     DPTR
001B E0                MOVX    A,@DPTR
001C         ?C0124:
001C 6013              JZ      ?C0011
                                           ; SOURCE LINE # 339
001E 90000000    R     MOV     DPTR,#CpuTouchSkipCount+01H
0022 E0                MOVX    A,@DPTR
0023 24FF              ADD     A,#0FFH
0025 F0                MOVX    @DPTR,A
0026 90000000    R     MOV     DPTR,#CpuTouchSkipCount
002A E0                MOVX    A,@DPTR
002B 34FF              ADDC    A,#0FFH
002D F0                MOVX    @DPTR,A
002E 010000      R     AJMP    ?C0010
                                           ; SOURCE LINE # 341
0031         ?C0011:
                                           ; SOURCE LINE # 343
0031 90000000    R     MOV     DPTR,#CpuTouchStep
0035 E0                MOVX    A,@DPTR
0036 FD                MOV     R5,A
0037 702E              JNZ     ?C0012
                                           ; SOURCE LINE # 345
0039 110000      R     ACALL   L?0144
003C E0                MOVX    A,@DPTR
003D 2B                ADD     A,R3
003E FB                MOV     R3,A
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 37  

003F E4                CLR     A
0040 3A                ADDC    A,R2
0041 FA                MOV     R2,A
                                           ; SOURCE LINE # 346
0042 D3                SETB    C
0043 EB                MOV     A,R3
0044 9400              SUBB    A,#00H
0046 EA                MOV     A,R2
0047 9408              SUBB    A,#08H
0049 4012              JC      ?C0013
                                           ; SOURCE LINE # 347
004B 110000      R     ACALL   L?0166
004E 110000      R     ACALL   L?0146
0051 7401              MOV     A,#01H
                                           ; SOURCE LINE # 348
                                           ; SOURCE LINE # 349
0053 110000      R     ACALL   L?0160
                                           ; SOURCE LINE # 350
0056 90000000    R     MOV     DPTR,#CpuZ2
                                           ; SOURCE LINE # 351
005A 010000      R     AJMP    ?C0140
005D         ?C0013:
                                           ; SOURCE LINE # 352
                                           ; SOURCE LINE # 353
005D 90000000    R     MOV     DPTR,#CpuTouchStep
0061 7405              MOV     A,#05H
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 354
                                           ; SOURCE LINE # 355
0064 010000      R     AJMP    ?C0010
0067         ?C0012:
                                           ; SOURCE LINE # 356
0067 ED                MOV     A,R5
0068 6401              XRL     A,#01H
006A 704A              JNZ     ?C0016
                                           ; SOURCE LINE # 358
006C 110000      R     ACALL   L?0144
                                           ; SOURCE LINE # 359
006F 110000      R     ACALL   L?0154
0072 500A              JNC     ?C0017
0074 110000      R     ACALL   L?0168
0077 110000      R     ACALL   L?0151
007A EF                MOV     A,R7
007B F0                MOVX    @DPTR,A
007C 8005              SJMP    ?C0018
007E         ?C0017:
                                           ; SOURCE LINE # 360
007E 110000      R     ACALL   L?0149
0081 CE                XCH     A,R6
0082 F0                MOVX    @DPTR,A
0083         ?C0018:
                                           ; SOURCE LINE # 362
0083 110000      R     ACALL   L?0158
0086 5027              JNC     ?C0019
                                           ; SOURCE LINE # 363
0088 C3                CLR     C
0089 EB                MOV     A,R3
008A 9464              SUBB    A,#064H
008C EA                MOV     A,R2
008D 9400              SUBB    A,#00H
008F 5014              JNC     ?C0020
                                           ; SOURCE LINE # 364
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 38  

0091 90000000    R     MOV     DPTR,#CpuTouchPressed
0095 E4                CLR     A
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 365
0097 90000000    R     MOV     DPTR,#CpuTouchStep
009B 7405              MOV     A,#05H
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 366
009E 90000000    R     MOV     DPTR,#CpuTouchChanged
                                           ; SOURCE LINE # 367
00A2 010000      R     AJMP    ?C0135
00A5         ?C0020:
                                           ; SOURCE LINE # 368
                                           ; SOURCE LINE # 369
00A5 110000      R     ACALL   L?0166
00A8 110000      R     ACALL   L?0146
00AB E4                CLR     A
                                           ; SOURCE LINE # 370
                                           ; SOURCE LINE # 371
                                           ; SOURCE LINE # 372
                                           ; SOURCE LINE # 373
00AC 010000      R     AJMP    ?C0136
00AF         ?C0019:
                                           ; SOURCE LINE # 374
                                           ; SOURCE LINE # 375
00AF 90000000    R     MOV     DPTR,#temp
00B3         ?C0134:
                                           ; SOURCE LINE # 377
                                           ; SOURCE LINE # 378
00B3 010000      R     AJMP    ?C0140
00B6         ?C0016:
                                           ; SOURCE LINE # 379
00B6 90000000    R     MOV     DPTR,#CpuTouchStep
00BA E0                MOVX    A,@DPTR
00BB F9                MOV     R1,A
00BC 6402              XRL     A,#02H
00BE 7034              JNZ     ?C0024
                                           ; SOURCE LINE # 381
00C0 110000      R     ACALL   L?0145
                                           ; SOURCE LINE # 383
00C3 110000      R     ACALL   L?0154
00C6 500A              JNC     ?C0025
00C8 110000      R     ACALL   L?0168
00CB 110000      R     ACALL   L?0151
00CE EF                MOV     A,R7
00CF F0                MOVX    @DPTR,A
00D0 8005              SJMP    ?C0026
00D2         ?C0025:
                                           ; SOURCE LINE # 384
00D2 110000      R     ACALL   L?0149
00D5 CE                XCH     A,R6
00D6 F0                MOVX    @DPTR,A
00D7         ?C0026:
                                           ; SOURCE LINE # 386
00D7 110000      R     ACALL   L?0158
00DA 5011              JNC     ?C0027
                                           ; SOURCE LINE # 387
00DC 110000      R     ACALL   L?0167
00DF 110000      R     ACALL   L?0146
00E2 7403              MOV     A,#03H
                                           ; SOURCE LINE # 388
                                           ; SOURCE LINE # 389
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 39  

00E4 110000      R     ACALL   L?0160
                                           ; SOURCE LINE # 390
00E7 90000000    R     MOV     DPTR,#TX
                                           ; SOURCE LINE # 391
00EB 8004              SJMP    ?C0132
00ED         ?C0027:
                                           ; SOURCE LINE # 392
                                           ; SOURCE LINE # 393
00ED 90000000    R     MOV     DPTR,#temp
00F1         ?C0132:
00F1         ?C0137:
                                           ; SOURCE LINE # 395
                                           ; SOURCE LINE # 396
00F1 010000      R     AJMP    ?C0140
00F4         ?C0024:
                                           ; SOURCE LINE # 397
00F4 E9                MOV     A,R1
00F5 6403              XRL     A,#03H
00F7 703C              JNZ     ?C0030
                                           ; SOURCE LINE # 399
00F9 110000      R     ACALL   L?0145
                                           ; SOURCE LINE # 401
00FC 110000      R     ACALL   L?0155
00FF 500A              JNC     ?C0031
0101 110000      R     ACALL   L?0169
0104 110000      R     ACALL   L?0151
0107 EF                MOV     A,R7
0108 F0                MOVX    @DPTR,A
0109 8005              SJMP    ?C0032
010B         ?C0031:
                                           ; SOURCE LINE # 402
010B 110000      R     ACALL   L?0150
010E CE                XCH     A,R6
010F F0                MOVX    @DPTR,A
0110         ?C0032:
                                           ; SOURCE LINE # 404
0110 110000      R     ACALL   L?0159
0113 5019              JNC     ?C0033
                                           ; SOURCE LINE # 405
0115 110000      R     ACALL   L?0167
0118 110000      R     ACALL   L?0146
011B 7401              MOV     A,#01H
011D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 406
011E 110000      R     ACALL   L?0162
                                           ; SOURCE LINE # 407
0121 90000000    R     MOV     DPTR,#CpuTouchStep
0125 E0                MOVX    A,@DPTR
0126 04                INC     A
0127 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 408
0128 90000000    R     MOV     DPTR,#TY
                                           ; SOURCE LINE # 409
012C 8004              SJMP    ?C0133
012E         ?C0033:
                                           ; SOURCE LINE # 410
                                           ; SOURCE LINE # 411
012E 90000000    R     MOV     DPTR,#temp
0132         ?C0133:
0132         ?C0138:
                                           ; SOURCE LINE # 413
                                           ; SOURCE LINE # 414
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 40  

0132 010000      R     AJMP    ?C0140
0135         ?C0030:
                                           ; SOURCE LINE # 415
0135 E9                MOV     A,R1
0136 6404              XRL     A,#04H
0138 707C              JNZ     ?C0036
                                           ; SOURCE LINE # 417
013A 110000      R     ACALL   L?0145
                                           ; SOURCE LINE # 419
013D 110000      R     ACALL   L?0155
0140 500A              JNC     ?C0037
0142 110000      R     ACALL   L?0169
0145 110000      R     ACALL   L?0151
0148 EF                MOV     A,R7
0149 F0                MOVX    @DPTR,A
014A 8005              SJMP    ?C0038
014C         ?C0037:
                                           ; SOURCE LINE # 420
014C 110000      R     ACALL   L?0150
014F CE                XCH     A,R6
0150 F0                MOVX    @DPTR,A
0151         ?C0038:
                                           ; SOURCE LINE # 422
0151 110000      R     ACALL   L?0159
0154 505A              JNC     ?C0039
                                           ; SOURCE LINE # 423
0156 C3                CLR     C
0157 EB                MOV     A,R3
0158 9464              SUBB    A,#064H
015A EA                MOV     A,R2
015B 9400              SUBB    A,#00H
015D 500F              JNC     ?C0040
                                           ; SOURCE LINE # 424
015F 90000000    R     MOV     DPTR,#CpuTouchPressed
0163 E4                CLR     A
0164 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 425
0165 90000000    R     MOV     DPTR,#CpuTouchChanged
0169 E0                MOVX    A,@DPTR
016A 04                INC     A
016B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 426
016C 8039              SJMP    ?C0041
016E         ?C0040:
                                           ; SOURCE LINE # 427
                                           ; SOURCE LINE # 431
016E 90000000    R     MOV     DPTR,#TX
0172 E0                MOVX    A,@DPTR
0173 FF                MOV     R7,A
0174 A3                INC     DPTR
0175 E0                MOVX    A,@DPTR
0176 90000000    R     MOV     DPTR,#CpuTouchX
017A CF                XCH     A,R7
017B F0                MOVX    @DPTR,A
017C A3                INC     DPTR
017D EF                MOV     A,R7
017E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 432
017F 90000000    R     MOV     DPTR,#TY
0183 E0                MOVX    A,@DPTR
0184 FF                MOV     R7,A
0185 A3                INC     DPTR
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 41  

0186 E0                MOVX    A,@DPTR
0187 90000000    R     MOV     DPTR,#CpuTouchY
018B CF                XCH     A,R7
018C F0                MOVX    @DPTR,A
018D A3                INC     DPTR
018E EF                MOV     A,R7
018F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 433
0190 90000000    R     MOV     DPTR,#CpuZ1
0194 EA                MOV     A,R2
0195 F0                MOVX    @DPTR,A
0196 A3                INC     DPTR
0197 EB                MOV     A,R3
0198 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 434
0199 90000000    R     MOV     DPTR,#CpuTouchChanged
019D E0                MOVX    A,@DPTR
019E 04                INC     A
019F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 435
01A0 90000000    R     MOV     DPTR,#CpuTouchPressed
01A4 7401              MOV     A,#01H
01A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 436
01A7         ?C0041:
                                           ; SOURCE LINE # 437
01A7 90000000    R     MOV     DPTR,#CpuTouchStep
01AB         ?C0135:
01AB E0                MOVX    A,@DPTR
01AC 04                INC     A
01AD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 438
01AE 8064              SJMP    ?C0010
01B0         ?C0039:
                                           ; SOURCE LINE # 439
                                           ; SOURCE LINE # 440
01B0 90000000    R     MOV     DPTR,#temp
01B4         ?C0139:
                                           ; SOURCE LINE # 442
                                           ; SOURCE LINE # 443
01B4 8059              SJMP    ?C0140
01B6         ?C0036:
                                           ; SOURCE LINE # 444
01B6 E9                MOV     A,R1
01B7 B4050D            CJNE    A,#05H,?C0044
                                           ; SOURCE LINE # 445
01BA 110000      R     ACALL   L?0167
01BD 110000      R     ACALL   L?0146
01C0 7407              MOV     A,#07H
01C2         ?C0136:
                                           ; SOURCE LINE # 446
                                           ; SOURCE LINE # 447
01C2 110000      R     ACALL   L?0161
                                           ; SOURCE LINE # 448
01C5 804D              SJMP    ?C0010
01C7         ?C0044:
                                           ; SOURCE LINE # 449
01C7 E9                MOV     A,R1
01C8 6406              XRL     A,#06H
01CA 7048              JNZ     ?C0010
                                           ; SOURCE LINE # 451
01CC 110000      R     ACALL   L?0145
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 42  

                                           ; SOURCE LINE # 453
01CF 110000      R     ACALL   L?0155
01D2 500A              JNC     ?C0047
01D4 110000      R     ACALL   L?0169
01D7 110000      R     ACALL   L?0151
01DA EF                MOV     A,R7
01DB F0                MOVX    @DPTR,A
01DC 8005              SJMP    ?C0048
01DE         ?C0047:
                                           ; SOURCE LINE # 454
01DE 110000      R     ACALL   L?0150
01E1 CE                XCH     A,R6
01E2 F0                MOVX    @DPTR,A
01E3         ?C0048:
                                           ; SOURCE LINE # 456
01E3 110000      R     ACALL   L?0159
01E6 5023              JNC     ?C0049
                                           ; SOURCE LINE # 457
01E8 90000000    R     MOV     DPTR,#CpuAUX3
01EC EA                MOV     A,R2
01ED F0                MOVX    @DPTR,A
01EE A3                INC     DPTR
01EF EB                MOV     A,R3
01F0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 458
01F1 90000000    R     MOV     DPTR,#CpuAUX3_Changed
01F5 E0                MOVX    A,@DPTR
01F6 04                INC     A
01F7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 459
01F8 110000      R     ACALL   L?0167
01FB 110000      R     ACALL   L?0146
01FE 7402              MOV     A,#02H
0200 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 460
0201 110000      R     ACALL   L?0162
                                           ; SOURCE LINE # 461
0204 90000000    R     MOV     DPTR,#CpuTouchStep
0208 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 462
0209 8009              SJMP    ?C0010
020B         ?C0049:
                                           ; SOURCE LINE # 463
                                           ; SOURCE LINE # 464
020B 90000000    R     MOV     DPTR,#temp
020F         ?C0140:
020F EA                MOV     A,R2
0210 F0                MOVX    @DPTR,A
0211 A3                INC     DPTR
0212 EB                MOV     A,R3
0213 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 466
                                           ; SOURCE LINE # 467
                                           ; SOURCE LINE # 468
0214         ?C0010:
0214 D0D0              POP     PSW
0216 D082              POP     DPL
0218 D083              POP     DPH
021A D093              POP     DPX
021C D0E0              POP     ACC
021E 32                RETI    
             ; FUNCTION timer1_int (END)
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 43  


             ; FUNCTION uart0_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0D0              PUSH    PSW
0004 75D010            MOV     PSW,#010H
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 508
0007 309829            JNB     SFRB_RI,?C0051
                                           ; SOURCE LINE # 509
000A C298              CLR     SFRB_RI
                                           ; SOURCE LINE # 511
000C E59E              MOV     A,SFR_UART0FIFO
000E 541F              ANL     A,#01FH
0010 FF                MOV     R7,A
;---- Variable 'count' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 512
0011 30E405            JNB     ACC.4,?C0054
                                           ; SOURCE LINE # 513
0014 759E90            MOV     SFR_UART0FIFO,#090H
                                           ; SOURCE LINE # 517
0017 801A              SJMP    ?C0051
                                           ; SOURCE LINE # 518
0019         ?C0054:
                                           ; SOURCE LINE # 523
0019 EF                MOV     A,R7
001A 6017              JZ      ?C0051
                                           ; SOURCE LINE # 524
001C AE00        R     MOV     R6,RS_in
001E 0500        R     INC     RS_in
0020 7400        R     MOV     A,#LOW RS_buf
0022 2E                ADD     A,R6
0023 F8                MOV     R0,A
0024 A699              MOV     @R0,SFR_SBUF
                                           ; SOURCE LINE # 525
0026 E500        R     MOV     A,RS_in
0028 C3                CLR     C
0029 9420              SUBB    A,#020H
002B 4003              JC      ?C0056
002D 750000      R     MOV     RS_in,#00H
0030         ?C0056:
                                           ; SOURCE LINE # 526
0030 1F                DEC     R7
                                           ; SOURCE LINE # 527
0031 80E6              SJMP    ?C0054
                                           ; SOURCE LINE # 528
                                           ; SOURCE LINE # 534
0033         ?C0051:
                                           ; SOURCE LINE # 536
0033 309904            JNB     SFRB_TI,?C0058
                                           ; SOURCE LINE # 537
0036 C299              CLR     SFRB_TI
                                           ; SOURCE LINE # 538
0038 C200        R     CLR     RS_Xbusy
                                           ; SOURCE LINE # 539
                                           ; SOURCE LINE # 540
003A         ?C0058:
003A D0D0              POP     PSW
003C D0E0              POP     ACC
003E 32                RETI    
             ; FUNCTION uart0_int (END)

             ; FUNCTION timer2_int (BEGIN)
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 44  

0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C093              PUSH    DPX
0006 C083              PUSH    DPH
0008 C082              PUSH    DPL
000A C0D0              PUSH    PSW
000C 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 594
                                           ; SOURCE LINE # 604
000F 200006            JB      g_access,?C0059
                                           ; SOURCE LINE # 605
0012 53C9FC            ANL     SFR_T2IF,#0FCH
0015 010000      R     AJMP    ?C0060
                                           ; SOURCE LINE # 607
0018         ?C0059:
                                           ; SOURCE LINE # 608
0018 53C9FC            ANL     SFR_T2IF,#0FCH
                                           ; SOURCE LINE # 611
001B A294              MOV     C,P1_4
001D 9200        R     MOV     sample,C
                                           ; SOURCE LINE # 612
001F 0500        R     INC     RemoTic+01H
0021 E500        R     MOV     A,RemoTic+01H
0023 7002              JNZ     ?C0125
0025 0500        R     INC     RemoTic
0027         ?C0125:
                                           ; SOURCE LINE # 641
0027 5407              ANL     A,#07H
0029 FF                MOV     R7,A
;---- Variable 'i' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 642
002A B40106            CJNE    A,#01H,?C0061
002D A200        R     MOV     C,sample
002F 9200        R     MOV     RemoPhase1,C
0031 806C              SJMP    ?C0060
0033         ?C0061:
                                           ; SOURCE LINE # 643
0033 EF                MOV     A,R7
0034 B40506            CJNE    A,#05H,?C0063
0037 A200        R     MOV     C,sample
0039 9200        R     MOV     RemoPhase2,C
003B 8062              SJMP    ?C0060
003D         ?C0063:
                                           ; SOURCE LINE # 645
003D EF                MOV     A,R7
003E 705F              JNZ     ?C0060
                                           ; SOURCE LINE # 646
0040 A200        R     MOV     C,RemoPhase1
0042 300001            JNB     RemoPhase2,?C0126
0045 B3                CPL     C
0046         ?C0126:
0046 400E              JC      ?C0066
                                           ; SOURCE LINE # 647
0048 C2AD              CLR     SFRB_ET2
                                           ; SOURCE LINE # 649
004A 75C800            MOV     SFR_T2CON,#00H
                                           ; SOURCE LINE # 650
004D 7800        R     MOV     R0,#LOW RemoDataReady
004F 7600              MOV     @R0,#00H
0051 43FB10            ORL     SFR_E2IE,#010H
0054 8049              SJMP    ?C0060
                                           ; SOURCE LINE # 653
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 45  

0056         ?C0066:
                                           ; SOURCE LINE # 654
0056 D3                SETB    C
0057 E500        R     MOV     A,RemoTic+01H
0059 9440              SUBB    A,#040H
005B E500        R     MOV     A,RemoTic
005D 9400              SUBB    A,#00H
005F 500F              JNC     ?C0067
                                           ; SOURCE LINE # 655
0061 7800        R     MOV     R0,#LOW RemoSystemCode
0063 E6                MOV     A,@R0
0064 FF                MOV     R7,A
0065 25E0              ADD     A,ACC
0067 F6                MOV     @R0,A
                                           ; SOURCE LINE # 656
0068 300016            JNB     RemoPhase1,?C0069
006B 200013            JB      RemoPhase2,?C0069
                                           ; SOURCE LINE # 657
                                           ; SOURCE LINE # 658
006E 800D              SJMP    ?C0141
0070         ?C0067:
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
0070 7800        R     MOV     R0,#LOW RemoDataCode
0072 E6                MOV     A,@R0
0073 FF                MOV     R7,A
0074 25E0              ADD     A,ACC
0076 F6                MOV     @R0,A
                                           ; SOURCE LINE # 661
0077 300007            JNB     RemoPhase1,?C0069
007A 200004            JB      RemoPhase2,?C0069
                                           ; SOURCE LINE # 662
007D         ?C0141:
007D E6                MOV     A,@R0
007E 4401              ORL     A,#01H
0080 F6                MOV     @R0,A
                                           ; SOURCE LINE # 663
0081         ?C0069:
                                           ; SOURCE LINE # 665
0081 C3                CLR     C
0082 E500        R     MOV     A,RemoTic+01H
0084 9470              SUBB    A,#070H
0086 E500        R     MOV     A,RemoTic
0088 9400              SUBB    A,#00H
008A 4013              JC      ?C0060
                                           ; SOURCE LINE # 666
008C 7800        R     MOV     R0,#LOW RemoDataReady
008E 06                INC     @R0
                                           ; SOURCE LINE # 673
008F AF00        R     MOV     R7,SystemClock+03H
0091 AE00        R     MOV     R6,SystemClock+02H
0093 AD00        R     MOV     R5,SystemClock+01H
0095 AC00        R     MOV     R4,SystemClock
0097 7800        R     MOV     R0,#LOW RemoReceivedTime
0099 110000      E     ACALL   ?C?LSTIDATA
                                           ; SOURCE LINE # 675
009C 75C800            MOV     SFR_T2CON,#00H
                                           ; SOURCE LINE # 676
                                           ; SOURCE LINE # 677
                                           ; SOURCE LINE # 678
009F         ?C0060:
009F D0D0              POP     PSW
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 46  

00A1 D082              POP     DPL
00A3 D083              POP     DPH
00A5 D093              POP     DPX
00A7 D0F0              POP     B
00A9 D0E0              POP     ACC
00AB 32                RETI    
             ; FUNCTION timer2_int (END)

             ; FUNCTION ext2_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C093              PUSH    DPX
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
                                           ; SOURCE LINE # 861
                                           ; SOURCE LINE # 869
0008 30000F            JNB     g_access,?C0073
000B         ?C0072:
                                           ; SOURCE LINE # 872
000B 110000      R     ACALL   L?0157
000E E0                MOVX    A,@DPTR
000F 90000000    R     MOV     DPTR,#val
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 873
0014 110000      R     ACALL   L?0157
0017 7480              MOV     A,#080H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 874
001A         ?C0073:
001A D082              POP     DPL
001C D083              POP     DPH
001E D093              POP     DPX
0020 D0E0              POP     ACC
0022 32                RETI    
             ; FUNCTION ext2_int (END)

             ; FUNCTION ext3_int (BEGIN)
                                           ; SOURCE LINE # 882
                                           ; SOURCE LINE # 888
0000 32                RETI    
             ; FUNCTION ext3_int (END)

             ; FUNCTION ext4_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C093              PUSH    DPX
0006 C083              PUSH    DPH
0008 C082              PUSH    DPL
000A C0D0              PUSH    PSW
000C 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 896
                                           ; SOURCE LINE # 902
000F 110000      R     ACALL   L?0147
                                           ; SOURCE LINE # 903
0012 110000      R     ACALL   L?0157
0015 E0                MOVX    A,@DPTR
0016 5410              ANL     A,#010H
0018 F500        R     MOV     INT_STATUS3,A
                                           ; SOURCE LINE # 904
001A 110000      R     ACALL   L?0157
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 907
001E D0D0              POP     PSW
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 47  

0020 D082              POP     DPL
0022 D083              POP     DPH
0024 D093              POP     DPX
0026 D0F0              POP     B
0028 D0E0              POP     ACC
002A 32                RETI    
             ; FUNCTION ext4_int (END)

             ; FUNCTION ext5_int (BEGIN)
                                           ; SOURCE LINE # 911
                                           ; SOURCE LINE # 917
0000 32                RETI    
             ; FUNCTION ext5_int (END)

             ; FUNCTION ext6_int (BEGIN)
                                           ; SOURCE LINE # 926
                                           ; SOURCE LINE # 932
0000 32                RETI    
             ; FUNCTION ext6_int (END)

             ; FUNCTION watchdog_int (BEGIN)
                                           ; SOURCE LINE # 953
                                           ; SOURCE LINE # 973
0000 759C00            MOV     SFR_CACHE_EN,#00H
                                           ; SOURCE LINE # 975
0003 32                RETI    
             ; FUNCTION watchdog_int (END)

             ; FUNCTION ext7_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C093              PUSH    DPX
0006 C083              PUSH    DPH
0008 C082              PUSH    DPL
000A C0D0              PUSH    PSW
000C 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 982
                                           ; SOURCE LINE # 984
000F 430001      R     ORL     EXINT_STATUS,#01H
                                           ; SOURCE LINE # 985
0012 110000      R     ACALL   L?0147
                                           ; SOURCE LINE # 990
0015 75FA01            MOV     SFR_E2IF,#01H
                                           ; SOURCE LINE # 991
0018 D0D0              POP     PSW
001A D082              POP     DPL
001C D083              POP     DPH
001E D093              POP     DPX
0020 D0F0              POP     B
0022 D0E0              POP     ACC
0024 32                RETI    
             ; FUNCTION ext7_int (END)

             ; FUNCTION ext8_int (BEGIN)
                                           ; SOURCE LINE # 995
                                           ; SOURCE LINE # 997
0000 430002      R     ORL     EXINT_STATUS,#02H
                                           ; SOURCE LINE # 1002
0003 75FA02            MOV     SFR_E2IF,#02H
                                           ; SOURCE LINE # 1003
0006 32                RETI    
             ; FUNCTION ext8_int (END)
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 48  


             ; FUNCTION ext9_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C093              PUSH    DPX
0006 C083              PUSH    DPH
0008 C082              PUSH    DPL
000A C0D0              PUSH    PSW
000C 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 1009
                                           ; SOURCE LINE # 1011
000F 430004      R     ORL     EXINT_STATUS,#04H
                                           ; SOURCE LINE # 1012
0012 110000      R     ACALL   L?0148
                                           ; SOURCE LINE # 1017
0015 75FA04            MOV     SFR_E2IF,#04H
                                           ; SOURCE LINE # 1018
0018 D0D0              POP     PSW
001A D082              POP     DPL
001C D083              POP     DPH
001E D093              POP     DPX
0020 D0F0              POP     B
0022 D0E0              POP     ACC
0024 32                RETI    
             ; FUNCTION ext9_int (END)

             ; FUNCTION ext10_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C093              PUSH    DPX
0006 C083              PUSH    DPH
0008 C082              PUSH    DPL
000A C0D0              PUSH    PSW
000C 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 1026
                                           ; SOURCE LINE # 1028
000F 430008      R     ORL     EXINT_STATUS,#08H
                                           ; SOURCE LINE # 1029
0012 110000      R     ACALL   L?0148
                                           ; SOURCE LINE # 1034
0015 75FA08            MOV     SFR_E2IF,#08H
                                           ; SOURCE LINE # 1036
0018 D0D0              POP     PSW
001A D082              POP     DPL
001C D083              POP     DPH
001E D093              POP     DPX
0020 D0F0              POP     B
0022 D0E0              POP     ACC
0024 32                RETI    
             ; FUNCTION ext10_int (END)

             ; FUNCTION ext11_int (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C093              PUSH    DPX
0006 C083              PUSH    DPH
0008 C082              PUSH    DPL
000A C0D0              PUSH    PSW
000C 75D008            MOV     PSW,#08H
                                           ; SOURCE LINE # 1041
                                           ; SOURCE LINE # 1043
000F 430010      R     ORL     EXINT_STATUS,#010H
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 49  

                                           ; SOURCE LINE # 1044
0012 110000      R     ACALL   L?0148
                                           ; SOURCE LINE # 1050
0015 53FBEF            ANL     SFR_E2IE,#0EFH
                                           ; SOURCE LINE # 1051
0018 75FA10            MOV     SFR_E2IF,#010H
                                           ; SOURCE LINE # 1053
001B 110000      R     ACALL   InitRemoTimer
                                           ; SOURCE LINE # 1054
001E D0D0              POP     PSW
0020 D082              POP     DPL
0022 D083              POP     DPH
0024 D093              POP     DPX
0026 D0F0              POP     B
0028 D0E0              POP     ACC
002A 32                RETI    
             ; FUNCTION ext11_int (END)

             ; FUNCTION ext12_int (BEGIN)
                                           ; SOURCE LINE # 1059
                                           ; SOURCE LINE # 1061
0000 430020      R     ORL     EXINT_STATUS,#020H
                                           ; SOURCE LINE # 1066
0003 75FA20            MOV     SFR_E2IF,#020H
                                           ; SOURCE LINE # 1067
0006 32                RETI    
             ; FUNCTION ext12_int (END)

             ; FUNCTION ext13_int (BEGIN)
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1073
0000 430040      R     ORL     EXINT_STATUS,#040H
                                           ; SOURCE LINE # 1078
0003 75FA40            MOV     SFR_E2IF,#040H
                                           ; SOURCE LINE # 1079
0006 32                RETI    
             ; FUNCTION ext13_int (END)

             ; FUNCTION ext14_int (BEGIN)
                                           ; SOURCE LINE # 1084
                                           ; SOURCE LINE # 1086
0000 430080      R     ORL     EXINT_STATUS,#080H
                                           ; SOURCE LINE # 1091
0003 75FA80            MOV     SFR_E2IF,#080H
                                           ; SOURCE LINE # 1092
0006 32                RETI    
             ; FUNCTION ext14_int (END)

             ; FUNCTION RS_ready (BEGIN)
                                           ; SOURCE LINE # 1107
                                           ; SOURCE LINE # 1108
                                           ; SOURCE LINE # 1109
0000 E500        R     MOV     A,RS_in
0002 7F01              MOV     R7,#01H
0004 B50002            CJNE    A,RS_out,?C0087
0007 7F00              MOV     R7,#00H
0009         ?C0087:
                                           ; SOURCE LINE # 1110
                                           ; SOURCE LINE # 1111
0009         ?C0088:
0009 22                RET     
             ; FUNCTION RS_ready (END)
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 50  


             ; FUNCTION RS_rx (BEGIN)
                                           ; SOURCE LINE # 1127
                                           ; SOURCE LINE # 1128
                                           ; SOURCE LINE # 1131
0000 C2AC              CLR     SFRB_ES
                                           ; SOURCE LINE # 1133
0002 7400        R     MOV     A,#LOW RS_buf
0004 2500        R     ADD     A,RS_out
0006 F8                MOV     R0,A
0007 E6                MOV     A,@R0
0008 FF                MOV     R7,A
;---- Variable 'ret' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1134
0009 0500        R     INC     RS_out
                                           ; SOURCE LINE # 1135
000B E500        R     MOV     A,RS_out
000D C3                CLR     C
000E 9420              SUBB    A,#020H
0010 4003              JC      ?C0090
                                           ; SOURCE LINE # 1136
0012 E4                CLR     A
0013 F500        R     MOV     RS_out,A
0015         ?C0090:
                                           ; SOURCE LINE # 1138
0015 D2AC              SETB    SFRB_ES
                                           ; SOURCE LINE # 1140
                                           ; SOURCE LINE # 1141
0017         ?C0091:
0017 22                RET     
             ; FUNCTION RS_rx (END)

             ; FUNCTION _RS_ungetch (BEGIN)
                                           ; SOURCE LINE # 1161
;---- Variable 'ch' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1162
                                           ; SOURCE LINE # 1163
0000 C2AC              CLR     SFRB_ES
                                           ; SOURCE LINE # 1164
0002 AE00        R     MOV     R6,RS_in
0004 0500        R     INC     RS_in
0006 7400        R     MOV     A,#LOW RS_buf
0008 2E                ADD     A,R6
0009 F8                MOV     R0,A
000A A607              MOV     @R0,AR7
                                           ; SOURCE LINE # 1165
000C E500        R     MOV     A,RS_in
000E C3                CLR     C
000F 9420              SUBB    A,#020H
0011 4003              JC      ?C0092
0013 E4                CLR     A
0014 F500        R     MOV     RS_in,A
0016         ?C0092:
                                           ; SOURCE LINE # 1166
0016 D2AC              SETB    SFRB_ES
                                           ; SOURCE LINE # 1167
0018 22                RET     
             ; FUNCTION _RS_ungetch (END)

             ; FUNCTION _RS_tx (BEGIN)
                                           ; SOURCE LINE # 1184
;---- Variable 'tx_buf' assigned to Register 'R7' ----
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 51  

                                           ; SOURCE LINE # 1185
0000         ?C0094:
                                           ; SOURCE LINE # 1186
0000 2000FD            JB      RS_Xbusy,?C0094
0003         ?C0095:
                                           ; SOURCE LINE # 1188
0003 C2AC              CLR     SFRB_ES
                                           ; SOURCE LINE # 1189
0005 8F99              MOV     SFR_SBUF,R7
                                           ; SOURCE LINE # 1190
0007 D200        R     SETB    RS_Xbusy
                                           ; SOURCE LINE # 1191
0009 D2AC              SETB    SFRB_ES
                                           ; SOURCE LINE # 1192
000B 22                RET     
             ; FUNCTION _RS_tx (END)

             ; FUNCTION _delay1ms (BEGIN)
                                           ; SOURCE LINE # 1236
;---- Variable 'cnt_1ms' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 1237
                                           ; SOURCE LINE # 1239
0000 C2A9              CLR     SFRB_ET0
                                           ; SOURCE LINE # 1240
0002 E4                CLR     A
0003 F500        R     MOV     tic_pc,A
0005 F500        R     MOV     tic_pc+01H,A
                                           ; SOURCE LINE # 1241
0007 D2A9              SETB    SFRB_ET0
0009         ?C0099:
                                           ; SOURCE LINE # 1242
                                           ; SOURCE LINE # 1243
0009 C2A9              CLR     SFRB_ET0
                                           ; SOURCE LINE # 1244
000B 90000000    R     MOV     DPTR,#temp_tic_pc
000F E500        R     MOV     A,tic_pc
0011 F0                MOVX    @DPTR,A
0012 A3                INC     DPTR
0013 E500        R     MOV     A,tic_pc+01H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1245
0016 D2A9              SETB    SFRB_ET0
                                           ; SOURCE LINE # 1246
0018 C3                CLR     C
0019 90000000    R     MOV     DPTR,#temp_tic_pc+01H
001D E0                MOVX    A,@DPTR
001E 9F                SUBB    A,R7
001F 90000000    R     MOV     DPTR,#temp_tic_pc
0023 E0                MOVX    A,@DPTR
0024 9E                SUBB    A,R6
0025 40E2              JC      ?C0099
                                           ; SOURCE LINE # 1247
0027 22                RET     
             ; FUNCTION _delay1ms (END)

             ; FUNCTION _delay1s (BEGIN)
                                           ; SOURCE LINE # 1252
;---- Variable 'line' assigned to Register 'R4/R5' ----
0000 90000000    R     MOV     DPTR,#cnt_1s
0004 EE                MOV     A,R6
0005 F0                MOVX    @DPTR,A
0006 A3                INC     DPTR
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 52  

0007 EF                MOV     A,R7
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1253
                                           ; SOURCE LINE # 1255
0009 7B00        R     MOV     R3,#MBYTE ?SC_0
000B 7A00        R     MOV     R2,#HIGH ?SC_0
000D 7900        R     MOV     R1,#LOW ?SC_0
000F 90000000    E     MOV     DPTR,#?_Printf?BYTE+03H
0013 EE                MOV     A,R6
0014 F0                MOVX    @DPTR,A
0015 A3                INC     DPTR
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
0018 AF05              MOV     R7,AR5
001A A3                INC     DPTR
001B EC                MOV     A,R4
001C F0                MOVX    @DPTR,A
001D A3                INC     DPTR
001E EF                MOV     A,R7
001F F0                MOVX    @DPTR,A
0020 110000      E     ACALL   _Printf
                                           ; SOURCE LINE # 1256
;---- Variable 'i' assigned to Register 'R4/R5' ----
0023 E4                CLR     A
0024 FD                MOV     R5,A
0025 FC                MOV     R4,A
0026         ?C0101:
0026 D3                SETB    C
0027 90000000    R     MOV     DPTR,#cnt_1s+01H
002B E0                MOVX    A,@DPTR
002C 9D                SUBB    A,R5
002D 90000000    R     MOV     DPTR,#cnt_1s
0031 E0                MOVX    A,@DPTR
0032 9C                SUBB    A,R4
0033 400E              JC      ?C0104
                                           ; SOURCE LINE # 1257
0035 7FE8              MOV     R7,#0E8H
0037 7E03              MOV     R6,#03H
0039 110000      R     ACALL   _delay1ms
                                           ; SOURCE LINE # 1258
003C 0D                INC     R5
003D BD0001            CJNE    R5,#00H,?C0127
0040 0C                INC     R4
0041         ?C0127:
0041 80E3              SJMP    ?C0101
                                           ; SOURCE LINE # 1259
0043         ?C0104:
0043 22                RET     
             ; FUNCTION _delay1s (END)

             ; FUNCTION RestartWatchdog (BEGIN)
                                           ; SOURCE LINE # 1301
                                           ; SOURCE LINE # 1302
                                           ; SOURCE LINE # 1303
0000 C2ED              CLR     SFRB_EWDI
                                           ; SOURCE LINE # 1305
0002 C2AF              CLR     SFRB_EA
                                           ; SOURCE LINE # 1306
0004 75EBAA            MOV     SFR_TA,#0AAH
                                           ; SOURCE LINE # 1307
0007 75EB55            MOV     SFR_TA,#055H
                                           ; SOURCE LINE # 1308
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 53  

000A 75D803            MOV     SFR_WDCON,#03H
                                           ; SOURCE LINE # 1309
000D D2AF              SETB    SFRB_EA
                                           ; SOURCE LINE # 1314
000F E59C              MOV     A,SFR_CACHE_EN
0011 7003              JNZ     ?C0105
                                           ; SOURCE LINE # 1315
0013 759C01            MOV     SFR_CACHE_EN,#01H
0016         ?C0105:
                                           ; SOURCE LINE # 1317
0016 D2ED              SETB    SFRB_EWDI
                                           ; SOURCE LINE # 1318
0018 22                RET     
             ; FUNCTION RestartWatchdog (END)

             ; FUNCTION _EnableWatchdog (BEGIN)
                                           ; SOURCE LINE # 1328
0000 90000000    R     MOV     DPTR,#mode
0004 EF                MOV     A,R7
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1329
                                           ; SOURCE LINE # 1330
0006 7B00        R     MOV     R3,#MBYTE ?SC_14
0008 7A00        R     MOV     R2,#HIGH ?SC_14
000A 7900        R     MOV     R1,#LOW ?SC_14
000C 90000000    E     MOV     DPTR,#?_Printf?BYTE+03H
0010 F0                MOVX    @DPTR,A
0011 110000      E     ACALL   _Printf
                                           ; SOURCE LINE # 1331
0014 C2ED              CLR     SFRB_EWDI
                                           ; SOURCE LINE # 1340
0016 538E3F            ANL     SFR_CKCON,#03FH
                                           ; SOURCE LINE # 1341
0019 90000000    R     MOV     DPTR,#mode
001D E0                MOVX    A,@DPTR
001E 14                DEC     A
001F 600A              JZ      ?C0109
0021 14                DEC     A
0022 600C              JZ      ?C0110
0024 14                DEC     A
0025 6011              JZ      ?C0107
0027 2403              ADD     A,#03H
                                           ; SOURCE LINE # 1342
0029         ?C0108:
0029 800A              SJMP    ?C0142
                                           ; SOURCE LINE # 1343
002B         ?C0109:
002B 438E80            ORL     SFR_CKCON,#080H
002E 8008              SJMP    ?C0107
                                           ; SOURCE LINE # 1344
0030         ?C0110:
0030 438E40            ORL     SFR_CKCON,#040H
0033 8003              SJMP    ?C0107
                                           ; SOURCE LINE # 1345
                                           ; SOURCE LINE # 1346
0035         ?C0142:
0035 438EC0            ORL     SFR_CKCON,#0C0H
                                           ; SOURCE LINE # 1347
0038         ?C0107:
                                           ; SOURCE LINE # 1348
0038 C2AF              CLR     SFRB_EA
                                           ; SOURCE LINE # 1349
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 54  

003A 75EBAA            MOV     SFR_TA,#0AAH
                                           ; SOURCE LINE # 1350
003D 75EB55            MOV     SFR_TA,#055H
                                           ; SOURCE LINE # 1351
0040 75D803            MOV     SFR_WDCON,#03H
                                           ; SOURCE LINE # 1352
0043 D2AF              SETB    SFRB_EA
                                           ; SOURCE LINE # 1354
0045 43F820            ORL     SFR_EIP,#020H
                                           ; SOURCE LINE # 1355
0048 D2ED              SETB    SFRB_EWDI
                                           ; SOURCE LINE # 1360
004A 22                RET     
             ; FUNCTION _EnableWatchdog (END)

             ; FUNCTION DisableWatchdog (BEGIN)
                                           ; SOURCE LINE # 1381
                                           ; SOURCE LINE # 1382
                                           ; SOURCE LINE # 1383
0000 C2ED              CLR     SFRB_EWDI
                                           ; SOURCE LINE # 1385
0002 C2AF              CLR     SFRB_EA
                                           ; SOURCE LINE # 1386
0004 75EBAA            MOV     SFR_TA,#0AAH
                                           ; SOURCE LINE # 1387
0007 75EB55            MOV     SFR_TA,#055H
                                           ; SOURCE LINE # 1388
000A E4                CLR     A
000B F5D8              MOV     SFR_WDCON,A
                                           ; SOURCE LINE # 1389
000D D2AF              SETB    SFRB_EA
                                           ; SOURCE LINE # 1391
000F 7B00        R     MOV     R3,#MBYTE ?SC_36
0011 7A00        R     MOV     R2,#HIGH ?SC_36
0013 7900        R     MOV     R1,#LOW ?SC_36
0015 010000      E     AJMP    _Puts
             ; FUNCTION DisableWatchdog (END)

             ; FUNCTION _EnableExtInterrupt (BEGIN)
                                           ; SOURCE LINE # 1399
;---- Variable 'intrn' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1400
                                           ; SOURCE LINE # 1401
0000 7401              MOV     A,#01H
0002 A807              MOV     R0,AR7
0004 08                INC     R0
0005 8002              SJMP    ?C0129
0007         ?C0128:
0007 C3                CLR     C
0008 33                RLC     A
0009         ?C0129:
0009 D8FC              DJNZ    R0,?C0128
000B 42FB              ORL     SFR_E2IE,A
                                           ; SOURCE LINE # 1402
000D 22                RET     
             ; FUNCTION _EnableExtInterrupt (END)

             ; FUNCTION _DisableExtInterrupt (BEGIN)
                                           ; SOURCE LINE # 1406
;---- Variable 'intrn' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1407
                                           ; SOURCE LINE # 1408
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 55  

0000 7401              MOV     A,#01H
0002 A807              MOV     R0,AR7
0004 08                INC     R0
0005 8002              SJMP    ?C0131
0007         ?C0130:
0007 C3                CLR     C
0008 33                RLC     A
0009         ?C0131:
0009 D8FC              DJNZ    R0,?C0130
000B F4                CPL     A
000C 52FB              ANL     SFR_E2IE,A
                                           ; SOURCE LINE # 1409
000E 22                RET     
             ; FUNCTION _DisableExtInterrupt (END)

             ; FUNCTION InitRemoTimer (BEGIN)
                                           ; SOURCE LINE # 1425
                                           ; SOURCE LINE # 1426
                                           ; SOURCE LINE # 1431
0000 E4                CLR     A
0001 F5C8              MOV     SFR_T2CON,A
                                           ; SOURCE LINE # 1433
0003 C2AD              CLR     SFRB_ET2
                                           ; SOURCE LINE # 1434
0005 F5C9              MOV     SFR_T2IF,A
                                           ; SOURCE LINE # 1437
0007 75CDFF            MOV     SFR_TH2,#0FFH
000A 75CBFF            MOV     SFR_RCRH,#0FFH
                                           ; SOURCE LINE # 1438
000D 75CC2E            MOV     SFR_TL2,#02EH
0010 75CA2E            MOV     SFR_RCRL,#02EH
                                           ; SOURCE LINE # 1440
0013 75CC2D            MOV     SFR_TL2,#02DH
0016 75CA2D            MOV     SFR_RCRL,#02DH
                                           ; SOURCE LINE # 1452
0019 75C812            MOV     SFR_T2CON,#012H
                                           ; SOURCE LINE # 1463
001C F500        R     MOV     RemoTic,A
001E 750004      R     MOV     RemoTic+01H,#04H
                                           ; SOURCE LINE # 1464
0021 D200        R     SETB    RemoPhase1
                                           ; SOURCE LINE # 1479
0023 7800        R     MOV     R0,#LOW RemoSystemCode
0025 F6                MOV     @R0,A
                                           ; SOURCE LINE # 1480
0026 18                DEC     R0
0027 F6                MOV     @R0,A
                                           ; SOURCE LINE # 1482
0028 D2AD              SETB    SFRB_ET2
                                           ; SOURCE LINE # 1483
002A 22                RET     
             ; FUNCTION InitRemoTimer (END)

             ; FUNCTION _init_cpu (BEGIN)
                                           ; SOURCE LINE # 1529
;---- Variable 'fWatchDog' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1530
                                           ; SOURCE LINE # 1535
0000 E4                CLR     A
0001 F59A              MOV     TWBASE,A
                                           ; SOURCE LINE # 1536
0003 75E201            MOV     SFR_CAMC,#01H
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 56  

                                           ; SOURCE LINE # 1538
0006 EF                MOV     A,R7
0007 7061              JNZ     ?C0118
                                           ; SOURCE LINE # 1540
0009 759300      E     MOV     DPX,#?C?XDATASEG
000C E500        R     MOV     A,regTW88+01H
000E 24E2              ADD     A,#0E2H
0010 110000      R     ACALL   L?0152
0013 7469              MOV     A,#069H
                                           ; SOURCE LINE # 1541
0015 110000      R     ACALL   L?0165
0018 24E3              ADD     A,#0E3H
001A 110000      R     ACALL   L?0152
001D 7478              MOV     A,#078H
                                           ; SOURCE LINE # 1543
001F 110000      R     ACALL   L?0165
0022 24E4              ADD     A,#0E4H
0024 110000      R     ACALL   L?0153
0027 7401              MOV     A,#01H
                                           ; SOURCE LINE # 1544
0029 110000      R     ACALL   L?0165
002C 24E5              ADD     A,#0E5H
002E 110000      R     ACALL   L?0153
0031 740E              MOV     A,#0EH
                                           ; SOURCE LINE # 1546
0033 110000      R     ACALL   L?0165
0036 24E6              ADD     A,#0E6H
0038 110000      R     ACALL   L?0153
                                           ; SOURCE LINE # 1547
003B 110000      R     ACALL   L?0163
003E 24E7              ADD     A,#0E7H
0040 110000      R     ACALL   L?0153
0043 741B              MOV     A,#01BH
                                           ; SOURCE LINE # 1549
0045 110000      R     ACALL   L?0165
0048 24E8              ADD     A,#0E8H
004A 110000      R     ACALL   L?0153
                                           ; SOURCE LINE # 1550
004D 110000      R     ACALL   L?0163
0050 24E9              ADD     A,#0E9H
0052 110000      R     ACALL   L?0153
0055 740C              MOV     A,#0CH
                                           ; SOURCE LINE # 1552
0057 110000      R     ACALL   L?0165
005A 24EA              ADD     A,#0EAH
005C 110000      R     ACALL   L?0153
                                           ; SOURCE LINE # 1553
005F 110000      R     ACALL   L?0164
0062 24EB              ADD     A,#0EBH
0064 110000      R     ACALL   L?0153
0067 740C              MOV     A,#0CH
0069 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1557
006A         ?C0118:
                                           ; SOURCE LINE # 1564
006A E4                CLR     A
006B F58E              MOV     SFR_CKCON,A
                                           ; SOURCE LINE # 1575
006D 758966            MOV     SFR_TMOD,#066H
                                           ; SOURCE LINE # 1587
0070 758855            MOV     SFR_TCON,#055H
                                           ; SOURCE LINE # 1597
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 57  

0073 758CFF            MOV     SFR_TH0,#0FFH
                                           ; SOURCE LINE # 1598
0076 758AFF            MOV     SFR_TL0,#0FFH
                                           ; SOURCE LINE # 1601
0079 758DCE            MOV     SFR_TH1,#0CEH
                                           ; SOURCE LINE # 1605
007C 75C812            MOV     SFR_T2CON,#012H
                                           ; SOURCE LINE # 1615
007F 75CDFF            MOV     SFR_TH2,#0FFH
                                           ; SOURCE LINE # 1616
0082 75CC2E            MOV     SFR_TL2,#02EH
                                           ; SOURCE LINE # 1618
0085 7587C0            MOV     SFR_PCON,#0C0H
                                           ; SOURCE LINE # 1628
0088 759850            MOV     SFR_SCON,#050H
                                           ; SOURCE LINE # 1638
008B 75C050            MOV     SFR_SCON1,#050H
                                           ; SOURCE LINE # 1649
008E 75B810            MOV     SFR_IP,#010H
                                           ; SOURCE LINE # 1659
0091 75A812            MOV     SFR_IE,#012H
                                           ; SOURCE LINE # 1672
0094 759E80            MOV     SFR_UART0FIFO,#080H
                                           ; SOURCE LINE # 1677
0097 D2AF              SETB    SFRB_EA
                                           ; SOURCE LINE # 1681
0099 75E804            MOV     SFR_EIE,#04H
                                           ; SOURCE LINE # 1690
009C F5F8              MOV     SFR_EIP,A
                                           ; SOURCE LINE # 1704
009E F5FB              MOV     SFR_E2IE,A
                                           ; SOURCE LINE # 1705
00A0 F5FC              MOV     SFR_E2IP,A
                                           ; SOURCE LINE # 1706
00A2 75FDFF            MOV     SFR_E2IM,#0FFH
                                           ; SOURCE LINE # 1707
00A5 F5FE              MOV     SFR_E2IT,A
                                           ; SOURCE LINE # 1711
00A7 7B00        R     MOV     R3,#MBYTE ?SC_53
00A9 7A00        R     MOV     R2,#HIGH ?SC_53
00AB 7900        R     MOV     R1,#LOW ?SC_53
00AD 110000      E     ACALL   _Puts
                                           ; SOURCE LINE # 1712
00B0 7B00        R     MOV     R3,#MBYTE ?SC_56
00B2 7A00        R     MOV     R2,#HIGH ?SC_56
00B4 7900        R     MOV     R1,#LOW ?SC_56
00B6 110000      E     ACALL   _Puts
                                           ; SOURCE LINE # 1713
00B9 E5D8              MOV     A,SFR_WDCON
00BB 30E209            JNB     ACC.2,?C0119
                                           ; SOURCE LINE # 1714
00BE 7B00        R     MOV     R3,#MBYTE ?SC_65
00C0 7A00        R     MOV     R2,#HIGH ?SC_65
00C2 7900        R     MOV     R1,#LOW ?SC_65
00C4 110000      E     ACALL   _Puts
00C7         ?C0119:
                                           ; SOURCE LINE # 1715
00C7 7B00        R     MOV     R3,#MBYTE ?SC_71
00C9 7A00        R     MOV     R2,#HIGH ?SC_71
00CB 7900        R     MOV     R1,#LOW ?SC_71
00CD 010000      E     AJMP    _Puts
             ; FUNCTION _init_cpu (END)
C51 COMPILER V9.56.0.0   CPU                                                               07/18/2018 10:44:33 PAGE 58  




MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2126    ----
   CONSTANT SIZE    =     73    ----
   XDATA SIZE       =     36       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     63    ----
   IDATA SIZE       =      7    ----
   BIT SIZE         =      4       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
